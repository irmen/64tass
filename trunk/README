64tass v1.5x manual

Original written for DOS by Marek Matula of Taboo, then ported to ansi C by
BigFoot/Breeze, and finally added 65816 support, DTV, illegal opcodes,
optimizations, multi pass compile and a lot of features by Soci/Singular.
Improved TASS compatibility, PETSCII codes by Groepaz.

Additional code: my_getopt command-line argument parser by Benjamin Sittler,
avl tree code by Franck Bui-Huu, ternary tree code by Daniel Berlin.

Syntax is the same as the well known Turbo Assembler on c64, so you can port
your sources easy by only replacing the CR at the end of each line.

Maintainer: soci at c64.rulez.org

This is a development version, features or syntax may change over time. Not
everything is backwards compatible.

-------------------------------------------------------------------------------

Usage tips

64tass is a command line compiler, the source can be written in any text
editor. As a minimum the source filename must be given on command line.

64tass src.asm

There are also some useful parameters which are described later.

For comfortable compiling I use such `Makefile's (for make):

demo.prg: source.asm makros.asm pic.drp music.bin
        64tass -C -a -B -i source.asm -o demo.tmp
        pucrunch -ffast -x 2048 demo.tmp >demo.prg

This way `demo.prg' is recreated by compiling `source.asm' whenever
`source.asm', `makros.asm', `pic.drp' or `music.bin' had changed.

Of course it's not much harder to create something similar for win32
(make.bat), however this will always compile and compress:

64tass.exe -C -a -B -i source.asm -o demo.tmp
pucrunch.exe -ffast -x 2048 demo.tmp >demo.prg

Here's a slightly more advanced Makefile example with default action as testing
in VICE, clean target for removal of temporary files and compressing using an
intermediate temporary file:

all: demo.prg
        x64 -autostartprgmode 1 -autostart-warp +truedrive +cart $<

demo.prg: demo.tmp
        pucrunch -ffast -x 2048 $< >$@

demo.tmp: source.asm makros.asm pic.drp music.bin
        64tass -C -a -B -i $< -o $@

.INTERMEDIATE: demo.tmp
.PHONY: all clean
clean:
        $(RM) demo.prg demo.tmp

Another useful thing is to add a basic header to your source files like the one
below, so that the resulting file is directly runnable without additional
compression:

        *= $0801
        .word (+), 2005   ;pointer, line number
        .null $9e, ^start;will be sys 4096
+       .word 0          ;basic line end

        *= $1000

start   rts

A frequently comming up question is, how to automatically allocate memory,
without hacks like *=*+1? Sure there's .byte and friends for variables with
initial values but what about zero page, or RAM outside of program area? The
solution is to not use an initial value by using '?' or not giving a fill byte
value to .fill.

        *= $02
p1      .word ?         ;a zero page pointer
temp    .fill 10        ;a 10 byte temporary area

Space allocated this way is not saved in the output as there's no data to save
at those addresses.

What about some code running on zero page for speed? It needs to be relocated,
and the length must be known to copy it there. Here's an example:

        ldx #size(zpcode)-1;calculate length
-       lda zpcode,x
        sta wrbyte,x
        dex             ;install to zeropage
        bpl -
        jsr wrbyte
        rts
;code continues here but is compiled to run from $02
zpcode  .logical $02
wrbyte  sta $ffff       ;quick byte writer at $02
        inc wrbyte+1
        bne +
        inc wrbyte+2
+       rts
        .here

For writing short code there are some special pseudo instructions for always
taken branches. These are automatically compiled as relative branches when the
jump distance is short enough and as JMP or BRL when longer. The names are
derived from conditional branches and are: GEQ, GNE, GCC, GCS, GPL, GMI, GVC,
and GVS.

There's one more called GRA for CPUs supporting BRA, which is expanded to BRL
(if available) or JMP.

.0000    a9 03          lda #$03        in1     lda #3
.0002    d0 02          gne $0006               gne at          ;branch always
.0004    a9 02          lda #$02        in2     lda #2
.0006    4c 00 10       gne $1000       at      gne $1000       ;branch further

If the branch would skip only one byte then the opposite condition is compiled
and only the first byte is emitted. This is now a never executed jump, and the
relative distance byte after the opcode is the jumped over byte.

If the branch would not skip anything at all then no code is generated.

.0009                   geq $0009               geq in3         ;zero length "branch"
.0009    18             clc             in3     clc
.000a    b0             gcc $000c               gcc at2         ;one byte skip, as bcs
.000b    38             sec             in4     sec             ;sec is skipped!
.000c    20 0f 00       jsr $000f       at2     jsr func
.000f                                   func

Please note that expressions like Gxx *+2 or Gxx *+3 are not allowed as the
compiler can't figure out if it has to create no code at all, the 1 byte
variant or the 2 byte one. Therefore use normal or anonymous labels defined
after the jump instruction when jumping forward!

To avoid branch too long errors the assembler also supports long branches, it
can automatically convert conditional relative branches to it's opposite and a
JMP or BRL. This can be enabled on the command line using the `--long-branch'
option.

.0000    ea             nop                     nop
.0001    b0 03 4c 00 10 bcc $1000               bcc $1000      ;long branch
.0006    ea             nop                     nop

Please note that forward jump expressions like Bxx *+130, Bxx *+131 and Bxx
*+132 are not allowed as the compiler can't decide between a short/long branch.
Of course these destinations can be used, but only with normal or anonymous
labels defined after the jump instruction.

There are some other tips below in the descriptions.

-------------------------------------------------------------------------------

Command line options

Output options

-o <filename>
    Place output into <filename>

    The default output filename is `a.out'. This option changes it.

    Example

    64tass a.asm -o a.prg

-b, --nostart
    Strip starting address

    Strips the 2 or 3 byte starting address before the resulting binary. Useful
    for creating small ROM images.

-f, --flat
    Flat output mode

    Output the plain binary image from offset 0. The image size can be much
    larger than the processor address space. Useful for creating huge multi
    bank ROM files.

-n, --nonlinear
    Generate nonlinear output file

    Generates non-linear output for linkers. Format: length, address, code,
    length, ...

    Example

    64tass --nonlinear a.asm
            *= $1000
            lda #2
            *= $2000
            nop
    result:
    $02, $00 ;little endian length, 2 bytes
    $00, $10 ;little endian start $1000
    $a9, $02 ;code
    $01, $00 ;little endian length, 1 byte
    $00, $20 ;little endian start $2000
    $ea      ;code
    $00, $00 ;end marker (length=0)

-W, --wordstart
    Force 2 byte start address

    If 16 MiB address space is used for a 65816, then the starting address of
    file will be 3 bytes long. This option makes it 2 bytes long.

    Example

    64tass --wordstart --m65816 a.asm

Operation options

-a, --ascii
    Use ASCII/Unicode text encoding instead of raw 8-bit

    Normally no conversion takes place, this is for backwards compatibility
    with a DOS based Turbo Assembler editor, which could create PETSCII files
    for 6502tass. (including control characters of course)

    Using this option will change the default `none' and `screen' encodings to
    map 'a'-'z' and 'A'-'Z' into the correct PETSCII range of $41-$5A and
    $C1-$DA, which is more suitable for an ASCII editor. It also adds
    predefined petcat style PETASCII literals to the default encodings.

    For writing sources in utf8/utf16 encodings this option is required! The
    symbol names are still limited to ASCII, but custom string encodings can
    take advantage of the full unicode set.

    Example

    64tass a.asm

    .0000    a9 61          lda #$61        lda #"a"

    >0002    31 61 41                       .text "1aA"
    >0005    7b 63 6c 65 61 72 7d 74        .text "{clear}text{return}more"
    >000e    65 78 74 7b 72 65 74 75
    >0016    72 6e 7d 6d 6f 72 65

    64tass --ascii a.asm

    .0000    a9 41          lda #$41        lda #"a"
    >0002    31 41 c1                       .text "1aA"
    >0005    93 54 45 58 54 0d 4d 4f        .text "{clear}text{return}more"
    >000e    52 45

-B, --long-branch
    Automatic BXX *+5 JMP xxx

    Branch too long messages can be annoying sometimes, usually they'll result
    in an BXX *+5 JMP xxx rewrite. 64tass can do this automatically if this
    option is used. But BRA is not converted.

    Example

    64tass a.asm
            *= $1000
            bcc $1233       ;error...

    64tass a.asm
            *= $1000
            bcs *+5         ;opposite condition
            jmp $1233       ;as simple workaround

    64tass --long-branch a.asm
            *= $1000
            bcc $1233       ;no error, automatically converted to the above one.

-C, --case-sensitive
    Case sensitive labels

    Labels are non case sensitive by default, this option changes that.

    Example

    64tass a.asm
    label   nop
    Label   nop     ;double defined...

    64tass --case-sensitive a.asm
    label   nop
    Label   nop     ;Ok, it's a different label...

-D <label>=<value>
    Define <label> to <value>

    Defines a label to a value. Same syntax is allowed as in source files. Be
    careful with string quoting, the shell might eat some of the characters.

    Example

    64tass -D ii=2 a.asm
            lda #ii ;result: $a9, $02

-w, --no-warn
    Suppress warnings

    Disables warnings during compile.

    Example

    64tass --no-warn a.asm

-q, --quiet
    Suppress messages

    Disables header and summary messages.

    Example

    64tass --quiet a.asm

-T, --tasm-compatible
    Enable TASM compatible operators and precedence

    Switches the expression evaluator into compatibility mode. This enables
    `.', `:' and `!' operators and disables 64tass specific extensions,
    disables precedence handling and forces 16 bit unsigned evaluation (see
    `differences to original Turbo Assembler' below)

Target selection on command line

These options will select the default architecture. It can be overridden by
using the .cpu directive in the source.

--m65xx
    Standard 65xx (default)

    Selects standard 6502. For writing compatible code, no extra codes. This is
    the default.

    Example

    64tass --m65xx a.asm
            lda $14         ;regular instructions

-c, --m65c02
    CMOS 65C02

    Selects 65c02. Enables extra opcodes and addressing modes specific to this
    CPU.

    Example

    64tass --m65c02 a.asm
            stz $d020       ;65c02 instruction

-i, --m6502
    NMOS 65xx

    Selects NMOS 6502. Enables extra illegal opcodes. Useful for demo coding
    for C64, disk drive code, etc.

    Example

    64tass --m6502 a.asm
            lax $14         ;illegal instruction

-t, --m65dtv02
    65DTV02

    Selects 65DTV02. Enables extra opcodes specific to DTV.

    Example

    64tass --m65dtv02 a.asm
            sac #$00

-x, --m65816
    W65C816

    Selects 65816. Enables extra opcodes, and full 16 MiB address space. Useful
    for SuperCPU projects. Don't forget to use `--word-start' for small ones ;)

    Example

    64tass --m65816 a.asm
            lda $123456,x

-e, --m65el02
    65EL02

    Selects 65EL02. Enables extra opcodes, useful RedPower CPU projects.
    Probably you'll need `--nostart' as well.

    Example

    64tass --m65el02 a.asm
            lda 0,r

--mr65c02
    R65C02

    Selects r65c02. Enables extra opcodes and addressing modes specific to this
    CPU.

    Example

    64tass --mr65c02 a.asm
            rmb 7,$20

--mw65c02
    W65C02

    Selects w65c02. Enables extra opcodes and addressing modes specific to this
    CPU.

    Example

    64tass --mw65c02 a.asm
            wai

Source listing options

-l <file>
    List labels into <file>

    List global labels to a file. Unused ones are marked with a comment.

    Example

    64tass -l labels.txt a.asm
            *= $1000
    label

    result (labels.txt):
    label           = $1000    ; *** unused

-L <file>
    List into <file>

    Dumps source code and compiled code into file. Useful for debugging, it's
    much easier to identify the code in memory within the source files.

    Example

    64tass -L list.txt a.asm
            *= $1000
            ldx #0
    loop    dex
            bne loop
            rts

    result (list.txt):

    ;64tass Turbo Assembler Macro V1.5x listing file of "a.asm"
    ;done on Fri Dec  9 19:08:55 2005


    .1000    a2 00          ldx #$00                ldx #0
    .1002    ca             dex             loop    dex
    .1003    d0 fd          bne $1002               bne loop
    .1005    60             rts                     rts

    ;******  end of code

-m, --no-monitor
    Don't put monitor code into listing

    There won't be any monitor listing in the list file.

    Example

    64tass --no-monitor -L list.txt a.asm

    result (list.txt):

    ;64tass Turbo Assembler Macro V1.5x listing file of "a.asm"
    ;done on Fri Dec  9 19:11:43 2005


    .1000    a2 00                                  ldx #0
    .1002    ca                             loop    dex
    .1003    d0 fd                                  bne loop
    .1005    60                                     rts

    ;******  end of code

-s, --no-source
    Don't put source code into listing

    There won't be any source listing in the list file.

    Example

    64tass --no-source -L list.txt a.asm

    result (list.txt):

    ;64tass Turbo Assembler Macro V1.5x listing file of "a.asm"
    ;done on Fri Dec  9 19:13:25 2005


    .1000    a2 00          ldx #$00
    .1002    ca             dex
    .1003    d0 fd          bne $1002
    .1005    60             rts

    ;******  end of code

Other options

-?, --help
    Give this help list

    Prints help about command line options.

--usage
    Give a short usage message

    Prints short help about command line options.

-V, --version
    Print program version

    Prints program version.

-------------------------------------------------------------------------------

Labels

Normal labels can be defined at the start of each line and hold the logical
address of that line, or the value after the equal sign. Each of them is uniq
and can't be redefined. Labels can be forward referenced, the assembler will
make as many passes as required to resolve them to a stable value.

reg     = $d020

loop
        inc reg
        jmp loop

Variables

Variables are redefinable, and as their value will be non stable forward
referencing is not allowed.

variabl .var 1
        .rept 10
        .byte variabl
variabl .var variabl+1
        .next

Anonymous labels

The assembler supports anonymous labels, also called as forward (+) and
backward (-) references. `-' means one backward, `--' means two backward, etc.
also the same for forward, but with `+'.

        ldy #4
-       ldx #0
-       txa
        cmp #3
        bcc +
        adc #44
+       sta $400,x
        inx
        bne -
        dey
        bne --

These references are also useful in segments, but this can create a nice traps,
as segments are copied into the code, with the internal references.

        bne +
        #somemakro      ;let's hope that this segment does
+       nop             ;not contain forward references...

Expressions

Numeric constants of decimal (0-9), hexadecimal ($) and binary (%) are
accepted. String constants are enclosed in quotation marks. To enter the
quotation mark itself in the string just double it. Single letter strings are
character constants and represent their numeric values in numeric expressions.

        .byte 23        ; decimal
        .byte $33       ; hex
        .byte %00011111 ; binary
        .byte 3.4       ; real

        .text "oeU"     ; text
        .text 'it''s'   ; text: it's

Parenthesis (( )) and brackets ([ ]) can be used to override operator
precedence. Don't forget that they also denote indirect addressing mode for
certain opcodes.

        lda #(4+2)*3

The dot (.) operator can be used to reference member elements of structs and
unions.

        lda storage.len

Brackets ([ ]) operator can be used to reference member elements of arrays by
their address. Indexing starts at 0.

        lda myarr[2],y
        ldx myarr[2]+1,y
myarr   .word 542,722,373,443

Built in functions are identifiers following parentheses. They accept variable
number of parameters separated by comma.

min(a, b, ...)        Minimum of values
max(a, b, ...)        Maximum of values
size(a)               Size of structure in bytes
abs(a)                Absolute value
sign(a)               Sign value (-1, 0, 1)
floor(a)              Round down
round(a)              Round to nearest away from zero
ceil(a)               Round up
trunc(a)              Round down towards zero
frac(a)               Fractional part
sqrt(a)               Square root
cqrt(a)               Cube root
log10(a)              Common logarithm
log(a)                Natural logarithm
exp(a)                Exponential
pow(a, b)             a raised to power of b
sin(a)                Sine
asin(a)               Arc sine
sinh(a)               Hyperbolic sine
cos(a)                Cosine
acos(a)               Arc cosine
cosh(a)               Hyperbolic cosine
tan(a)                Tangent
atan(a)               Arc tangent
tanh(a)               Hyperbolic tangent
rad(a)                Degrees to radian
deg(a)                Radian to degrees
hypot(y, x)           Polar distance
atan2(y, x)           Polar angle

There are no predefined math constants, however pi is rad(180) and e is exp(1).

Single bytes of numeric values can be extracted by the lower byte (<), higher
byte (>) and bank byte (`) operators.

        lda #<label
        ldy #>label
        jsr $ab1e

Special addressing mode forcing operators in front of an expression can be used
to make sure the expected addressing mode is used.

@b          to force 8 bit address
@w          to force 16 bit address
@l          to force 24 bit address (65816)

Boolean operators give 0 or 1 as a result.

x || y      or
x ^^ y      exclusive or
x && y      and
!x          not

The conditional operator gives the first (x) result if c is true or the second
(y) if c is false.

c ? x : y   ternary

Comparison operators result in 1 or 0 depending on the result.

x = y       equal
x != y      non equal
x < y       less
x > y       more
x >= y      more or equal
x <= y      less or equal

        .if ntsc=1
        nop
        .fi

There's a variety of bitwise operations available.

x | y    bitwise or
x ^ y    bitwise xor
x & y    bitwise and
x << y   logical shift left
x >> y   arithmetic shift right
x >>> y  logical shift right
~x       invert bits

        lda #((bitmap & $2000) >> 10) | ((screen & $3c00) >> 6)
        sta $d018
        lda $d015
        and #~%00100000
        sta $d015

And the regular arithmetic operations are supported as well.

x + y    add
x - y    substract
x * y    multiply
x / y    divide
x // y   modulo
x ** y   exponentiation
-x       negate
+x       unchanged

-------------------------------------------------------------------------------

Compiler directives:

Controlling the program counter

There are two address counters. One is used for placing the data in memory, the
other one called logical address, and it's what the labels will be set or what
the special star label gets when referenced.

*= <expression>
    Set both compile address and logical address. The compile address is moved
    so that the logical address will match at this point. If confused about
    what this means, see the example at .logical.

            *= $1000

.offs <expression>
    Add a compile offset to logical address.

            .offs 100

.logical <expression>
.here
    Changes logical address, compile address is not changed. Can be nested.

            .logical $300
    drive   lda #$80
            sta $00
            jmp drive       ;jmp $300
            rts
            .here

    Here's an example how .logical and *= works together:

            *= $0800       ;Compile: $0800, Logical: $0800
            .logical $1000 ;Compile: $0800, Logical: $1000
            *= $1200       ;Compile: $0a00, Logical: $1200
            .here          ;Compile: $0a00, Logical: $0a00

.align <modulo>[, <fill>]
    Align code to a dividable address by skip or fill

            .align $100
    irq     inc $d019       ;this will be on a page boundary, after skipping bytes
            .align 4, $ea
    loop    adc #1          ;padding with "nop" for DTV burst mode

Dumping data

.text <expression>[, <expression>, ...]
    Include constants and strings:

            .text "oeU"     ; text, "" means $22
            .text 'oeU'     ; text, '' means $27
            .text 23, $33   ; bytes
            .text %00011111 ; more bytes
            .text ^OEU      ; the decimal value as string (^23 is $32,$33)

.shift <expression>[, <expression>, ...]
    Same as .text, but the last byte will have the highest bit set. Any
    character which already has the most significiant bit set will cause an
    error.

            ldx #0
    loop    lda txt,x
            php
            and #$7f
            jsr $ffd2
            inx
            plp
            bpl loop
            rts
    txt     .shift "some text"

.shiftl <expression>[, <expression>, ...]
    Same as .text, but all bytes are shifted to left, and the last character
    gets the lowest bit set. Any character which already has the most
    significiant bit set will cause an error as this would be cut off.

            ldx #0
    loop    lda txt,x
            lsr
            sta $400,x
            inx
            bcc loop
            rts
            .enc screen
    txt     .shiftl "some text"
            .enc none

.null <expression>[, <expression>, ...]
    Same as .text, but adds a null at the end, null in string is an error.

    txt     .text "lot of stuff"
            .null "to write"
            lda #<txt
            ldy #>txt
            jsr $ab1e

.ptext <expression>[, <expression>, ...]
    Same as .text, but prepend the number of bytes in front of the string
    (pascal style string). Longer than 255 bytes are not allowed.

            lda #<txt
            ldx #>txt
            jsr print
            rts

    print   sta $fb
            stx $fc
            ldy #0
            lda ($fb),y
            beq null
            tax
    -       iny
            lda ($fb),y
            jsr $ffd2
            dex
            bne -
    null    rts

    txt     .ptext "note"

.byte <expression>[, <expression>, ...]
    Include 8 bit unsigned byte constants

            .byte 255       ; $ff
            .byte ?         ; reserve 1 byte of space

.char <expression>[, <expression>, ...]
    Include 8 bit signed integer constants

            .char -33, 57

.word <expression>[, <expression>, ...]
    Include 16 bit unsigned word constants

            .word $2342, $4555
            .word ?         ; reserve 2 bytes of space

.int <expression>[, <expression>, ...]
    Include 16 bit signed integer constants

            .int -533, 4433

.rta <expression>[, <expression>, ...]
    Include return address constants, which are one byte less than the
    original.

            lda #0
            asl
            tax
            lda rets+1,x
            pha
            lda rets,x
            pha
            rts
    rets    .rta $fce2

.long <expression>[, <expression>, ...]
    Include 24 bit unsigned constants

            .long $123456
            .long ?         ; reserve 3 bytes of space

.dword <expression>[, <expression>, ...]
    Include 32 bit unsigned constants

            .dword $12345678
            .dword ?        ; reserve 4 bytes of space

.dint <expression>[, <expression>, ...]
    Include 32 bit signed integer constants

            .dint -533, 4433

.fill <length>[, <fill>]
    Skip bytes, or fill with repeated bytes. For multi byte patterns use .rept!

            .fill $100      ;no fill, just reserve $100 bytes
            .fill $4000, 0  ;16384 bytes of 0

Text encoding

64tass supports sources written in utf8, utf16 (be/le) and raw 8-bit encoding.
To take advantage of this capability custom encodings can be defined to map
unicode characters to 8 bit values in strings.

.enc <name>
    Selects text encoding, predefined encodings are `none' and `screen' (screen
    code), anything else is user defined. All user encodings start without any
    character or escape definitions, add some as required.

            .enc screen     ;screencode mode
            .text "text with screencodes"
            cmp #"u"        ;compare screencode
            .enc none       ;normal mode again
            cmp #"u"        ;compare ascii

.cdef <start>, <end>, <coded> [, <start>, <end>, <coded>, ...]
.cdef "<start><end>", <coded> [, "<start><end>", <coded>, ...]
    Defines a character range, and assigns all characters one by one from the 8
    bit value. The start and end positions are unicode character codes either
    by numbers or by typing them.
.edef "<escapetext>", <code> [, "<escapetext>", <code>, ...]
    Defines an escape sequence, and assigns it to a 8 bit value. When using
    common prefixes the longest match wins. Useful for defining non-typeable
    control code aliases.

            .enc petscii    ;define an ascii->petscii encoding
            .cdef " @", 32  ;characters
            .cdef "AZ", $c1
            .cdef "az", $41
            .cdef "[[", $5b
            .cdef "??", $5c
            .cdef "]]", $5d
            .cdef "??", $5e
            .cdef $2190, $2190, $1f;left arrow

            .edef "\n", 13  ;escape sequences
            .edef "{clr}", 147

            .text "{clr}Text in PETSCII\n"

Structured data

Structures can be defined to organize sequential data definitions, which can be
reused later many times. The offset of fields are available by using the
definition's name as a base, and the fields themselves by using the instance
name before the dot operator. The length of a struct is the sum of lengths of
all items.

.struct
    Start structure definition
.ends
    Finish structure definition
.dstruct <name>
    Create instance of struct

            .struct         ;anonymous struct
    x       .byte 0         ;labels are visible
    y       .byte 0         ;content compiled here
            .ends           ;useful inside unions

    nn_s    .struct         ;named struct
    x       .byte 0         ;labels are not visible
    y       .byte 0         ;no content is compiled here
            .ends           ;it's just a definition

    nn      .dstruct nn_s   ;struct instance, content here

            lda nn.x        ;access internal fields
            ldy #nn_s.x     ;get offset of field

Unions are similar to structs, except each line will start on the same address
where the definition was done. The length of the union is the length of it's
longest item. The offset of fields are available by using the definition's name
as a base, and the fields themselves by using the instance name before the dot
operator. These offsets and references mostly point to the start of the union,
unless internal anonymous structs are used.

.union
    Start structure definition
.endu
    Finish structure definition
.dunion <name>
    Create instance of struct

            .union          ;anonymous union
    x       .byte 0         ;labels are visible
    y       .word 0         ;content compiled here
            .endu

    nn_u    .union          ;named union
    x       .byte 0         ;labels are not visible
    y       .word 0         ;no content is compiled here
            .endu           ;it's just a definition

    nn      .dunion nn_u    ;union instance here

            lda nn.x        ;access internal fields
            ldy #nn_u.x     ;get offset of field

    The example below shown how to define structure to a binary include.

            .union
            .binary "pic.drp",2
            .struct
    color   .fill 1024
    screen  .fill 1024
    bitmap  .fill 8000
    backg   .byte ?
            .ends
            .endu

    Anonymous structs and unions in combination with sections are useful for
    overlapping memory assignment. The example below shares zeropage
    allocations for two separate parts of a bigger program. The common
    subroutine variables are assigned after in the `zp' section.

            *= $02
            .union          ;spare some memory
            .struct
            .dsection zp1   ;declare zp1 section
            .send zp1
            .ends
            .struct
            .dsection zp2   ;declare zp2 section
            .send zp2
            .ends
            .endu
            .dsection zp    ;declare zp section
            .send zp

Macros

.macro
    Each invocation is a copy of the macro's content. The code is enclosed in
    it's own block so symbols inside are non-accessible.
.segment
    Only copies the code segment as it is, so symbols can be used from outside,
    but this also means multiple use will result in double defines unless
    anonymous labels are used.
.endm
    End of .macro or .segment definition

    fill    .macro
    lp      sta \1,x
            inx
            bne lp
            .endm

    name    .segment
            sta $d020
            sta $d021
            .endm

            lda #1
            #name           ;call macro
            #fill $400
            #fill $500

Parameter references

    Parameters can be referenced by \1...\9 and \a...\z. \@ will return the
    entire parameter list.

    name    .macro
            lda #\1         ;first parameter
            .endm

            #name 23        ;call macro

Text references

    In the original turbo assembler normal references are passed by value and
    can only appear in place of one. Text references on the other hand can
    appear every where and will work in place of eg quoted text or opcodes and
    labels. The first 9 parameters can be referenced as text by @1...@9.

    name    .macro
            jsr print
            .null "Hello @1!";first parameter
            .endm

            #name wth?      ;call macro

Conditional assembly

.if <expression>
.ifne <expression>
    Conditional compile, if result is not 0
.ifeq <expression>
    Conditional compile, if result is 0
.ifpl <expression>
    Conditional compile, if result is greater or equal 0
.ifmi <expression>
    Conditional compile, if result is less than 0
.fi
.endif
    End of conditional compile

            .if oeu=1
            nop
            .else
            lda #1
            .fi

.else
    Compile, if the previous conditions were not true.
.elsif <expression>
    Conditional compile, if the previous conditions were not true and the
    result is not 0.

            .if wait=2      ;2 cycles
            nop
            .elsif wait=3   ;3 cycles
            bit $ea
            .elsif wait=4   ;4 cycles
            bit $eaea
            .else           ;else 5 cycles
            inc $2
            .fi

.for <variable>=<expression>,<expression>,<variable>=<expression>
.next
    Compile loop, only anonymous references are allowed as labels inside

            .for ue=0,ue<10,ue=ue+1
            .byte ue
            .next

.rept <expression>
.next
    Repeated compile, only anonymous references are allowed as labels inside

            .rept 100
            nop
            .next

.lbl
    Creates a special jump label that can be referenced by .goto
.goto <labelname>
    Causes assembler to continue assembling from the jump label. No forward
    references of course, handle with care. Typically used in classic TASM
    sources for creating loops.

    i       .var 100
    loop    .lbl
            nop
    i       .var i - 1
            .ifne i
            .goto loop       ;generates 100 nops
            .fi

Including files

.include "<filename>"
    Include source file here, path is relative to the location of current
    source file. The filename can be a string expression but it must be defined
    in advance.

            .include "macros.asm"

.binary "<filename>"[, <offset>[, <length>]]
    Include binary data, path is relative to the location of current source
    file. Please note that `loading address' is ignored, and if not skipped
    then it's also loaded as data. By using offset and length it's possible to
    break out chunks of data from a file separately, like bitmap and colors for
    example. The filename can be a string expression.

            .binary "stuffz.bin"        ;simple include, all bytes
            .binary "stuffz.bin",2      ;skip start address
            .binary "stuffz.bin",2,1000 ;skip start address, 1000 bytes max

            *= $1000                    ;load music to $1000 and
            .binary "music.dmc",2       ;strip load address

Blocks

.proc
    Procedure start
.pend
    End of procedure

    ize     .proc
            nop
    cucc    nop
            .pend

            jsr ize
            jmp ize.cucc

    If `ize' is not referenced then the code won't be compiled at all! All
    labels inside are local.
.block
    Block start
.bend
    End of Block

            .block
            inc count + 1
    count   ldx #0
            .bend

    All labels inside a block are local.
.comment
    Comment block start
.endc
    End of comment block

            .comment
            lda #1          ;this won't be compiled
            sta $d020
            .endc

Sections

.dsection <name>
    Declares a named section and starts it.
.section <name>
    Section start
.send [<name>]
    End of section. Section name is optional, if present it must match.

    Sections are useful for linking sources, or to organize memory layout. With
    them it's easily possible to allocate addresses for variables at the place
    of actual use enclosed by the current scope. It can also be used to collect
    data or code to specific memory areas, or to ease the generation of code
    and data to multiple locations simultaniously in a single loop or macro.

    All .section-s scattered around in the sources are compiled from the
    .dsection declaration. Compilation happens as the code appears, this
    directive only assigns enough space to hold all the stuff in the sections.
    Where the .dsection appears the section's private address and logical
    address are initialized to the current values.

    The space allocated is calculated by the difference of the initial private
    address and the private address after the last section was compiled. It is
    possible to adjust the address in sections in a non incremental way, but it
    must be done carefully otherwise the space allocation will be not right, in
    that case you must manually adjust the address and logical address after
    the section declaration.

    Sections and section declarations can be nested, therefore it's possible to
    have the same names as long as it's inside a differently named section.
    Parent section names are visible for children, siblings can be reached
    through parents.

            *= $02
            .dsection zp   ;declare zeropage section
            .send zp
            .cerror *>$30,"Too many zeropage variables"

            *= $334
            .dsection bss   ;declare uninitialized variable section
            .send bss
            .cerror *>$400,"Too many variables"

            *= $0801
            .dsection code   ;declare code section
            .word ss, 2005
            .null $9e, ^start
    ss      .word 0
            .send code
            .cerror *>$1000,"Program too long!"

            *= $1000
            .dsection data   ;declare data section
            .send data
            .cerror *>$2000,"Data too long!"
    ;--------------------
            .section code
    start   sei
            .section zp     ;declare some new zeropage variables
    p2      .word ?         ;a pointer
            .send zp
            .section bss    ;new variables
    buffer  .fill 10        ;temporary area
            .send bss

            lda (p2),y
            lda #<label
            ldy #>label
            jsr print

            .section data   ;some data
    label   .null "message"
            .send data

            jmp error
            .section zp     ;declare some more zeropage variables
    p3      .word ?         ;a pointer
            .send zp
            .send code

    The compiled code will look like:

>0801    0b 08 d5 07                            .word ss, 2005
>0805    9e 32 30 36 31 00                      .null $9e, ^start
>080b    00 00                          ss      .word 0

                                                *= $1000

.080d    78                             start   sei

>0002                                   p2      .word ?         ;a pointer
.0334                                   buffer  .fill 10        ;temporary area

.080e    b1 02                                  lda (p2),y
.0810    a9 00                                  lda #<label
.0812    a0 10                                  ldy #>label
.0814    20 1e ab                               jsr print

>1000    6d 65 73 73 61 67 65 00        label   .null "message"

.0817    4c e2 fc                               jmp error

>0004                                   p2      .word ?         ;a pointer

65816 related

.as
    Select 8 bit accu (65816)
.al
    Select 16 bit accu (65816). Immediate constants of a register using opcodes
    will use 16 bits.

            .al
            lda #$4322

.xs
    Select 8 bit index (65816)
.xl
    Select 16 bit index (65816). Immediate constants of x and y register using
    opcodes will use 16 bits.

            .xl
            ldx #$1000

.databank <expression>
    Set databank (65816). Absolute addressing is used only for symbols in this
    bank, anything else (except direct page) is using long addressing.

            .databank $10   ;$10xxxx

.dpage <expression>
    Set directpage (65816/C128/DTV) (forced to page boundary for DTV). Direct
    page addressing is only used for addresses in the following 256 byte range,
    anything else is using absolute or long addressing.

            .dpage $400

Controlling errors

.page
    Gives an error on page boundary crossing, eg. for timing sensitive code.
.endp
    End of page cross checking

            .page
    table   .byte 0,1,2,3,4,5,6,7
            .endp

.option allow_branch_across_page
    Switches error generation on page boundary crossing during relative branch.
    Such a condition on 6502 adds 1 extra cycle to the execution time, which
    can ruin the timing of a carefuly cycle counted code.

            .option allow_branch_across_page = 0
            ldx #3          ;now this will execute in
    -       dex             ;16 cycles for sure
            bne -
            .option allow_branch_across_page = 1

.error <message> [, <message>, ...]
    Exit with error
.cerror <expression>, <message> [, <message>, ...]
    Conditional exit with error

            .error "Unfinished here..."
            .cerror *>$1200, "Program too long by ", *-$1200, " bytes"

.warn <message> [, <message>, ...]
    Warning
.cwarn <expression>, <message> [, <message>, ...]
    Conditional warning

            .warn "FIXME: handle negative values too!"
            .cwarn *>$1200, "This may not work!"

Target

.cpu <cpuname>
    Selects cpu

            .cpu 6502       ;standard 65xx
            .cpu 65c02      ;CMOS 65C02
            .cpu 6502i      ;NMOS 65xx
            .cpu 65816      ;W65C816
            .cpu 65dtv02    ;65dtv02
            .cpu 65el02     ;65el02
            .cpu r65c02     ;R65C02
            .cpu w65c02     ;W65C02
            .cpu default    ;cpu set on commandline

Misc

.end
    Terminate assembly. Any content after this directive is ignored.
.eor <expression>
    Eor output with some 8 bit value. Useful for reverse screencode text for
    example, or for silly `encryption'.
.var <expression>
    Defines a variable identified by the label preceeding, which is set to the
    value of expression.
.assert
.check
    Do not use these, the syntax will change in next version!

Printer control

.pron
.proff
    Turn on or off source listing on part of the file.
.hidemac
.showmac
    Ignored for compatibility

-------------------------------------------------------------------------------

How to convert source code written for the original turbo assembler for use
with 64tass

Currently there are two options, either use `TMPview' by Style to convert the
sourcefile directly, or do the following:

  * load turbo assembler, start (by sys9*4096 or sys8*4096 depending on
    version)
  * <- (arrow left) then l to load a sourcefile
  * <- (arrow left) then w to write a sourcefile in petscii format
  * convert the result to ascii using petcat (from the vice package)

the resulting file should then (with the restrictions below) assemble using the
following commandline:

64tass -C -T -a -W -i source.s -o outfile.prg

-------------------------------------------------------------------------------

Differences to the original turbo ass macro on the C64

64tass is nearly 100% compatible with the original `Turbo Assembler', and
supports most of the features of the original `Turbo Assembler Macro'. The
remaining notable differences are listed here:

Labels

The original turbo assembler uses case sensitive labels, use the -C,
--case-sensitive option to enable this behaviour.

Another thing worth noting is that the original turbo assembler lets you create
an interesting ambiguous construct using a label called `a'.

        lsr a    ; uses accu ! (or does it really?)
a
        jmp a    ; uses the label address
        .word a  ; uses the label address

If you get a warning like `warning: Possibly incorrectly used A "lsr a"', then
there is such an ambiguous situation in your code and you should fix it (by
renaming the label).

Expression evaluation

There are a few differences which can be worked around by the -T,
--tasm-compatible option. These are:

The original expression parser has no operator precedence, but 64tass has. That
means that you will have to fix expressions using braces accordingly, for
example 1+2*3 becomes (1+2)*3.

The following operators used by the original Turbo Assembler are different:

  * . for bitwise or, now |
  * : for bitwise eor, now ^
  * ! to force 16 bit address, now @w

The default expression evaluation is not limited to 16 bit unsigned numbers
anymore.

Macros

  * Macro parameters are referenced by \1...\9 instead of using the pound sign
  * Parameters are always copied as text into the macro and not passed by value
    as the original turbo assembler does, which sometimes may lead to
    unexpected behaviour. You may need to make use of braces around arguments
    and/or references to fix this.

Bugs

Some versions of the original turbo assembler had bugs that are not reproduced
by 64tass, you will have to fix the code instead.

  * In some versions labels used in the first .block are globally available. If
    you get a related error move the respective label out of the .block

-------------------------------------------------------------------------------

Messages

Warnings

Top of memory excedeed
    compile continues at the bottom ($0000)
Possibly incorrectly used A
    do not use `a' as label
Memory bank excedeed
    compile continues in the next 64 KiB bank, however execution may not
Possible jmp ($xxff) bug
    yet another 65xx feature...
Long branch used
    Branch too long, so long branch was used (bxx *+5 jmp)
Directive ignored
    An assembler directive was ignored for compatibility reasons.

Errors

Double defined
    double use of label/macro
Not defined
    not defined label
Extra characters on line
    there's some garbage on the end of line
Constant too large
    the number was too big
General syntax
    can't do anything with this
X expected
    X may be missing
Expression syntax
    syntax error
Branch too far
    can't relative branch that far
Missing argument
    no argument given
Illegal operand
    can't be used here
Requirements not met:
    Not all features are provided, at least one is missing
Conflict:
    at least one feature is provided, which shouldn't be there
Division by zero
    Cannot calculate value

Fatal errors

Can't locate file
    cannot open file
Out of memory
    won't happen ;)
Can't write object file:
    cannot write the result
Line too long
    input line was too long
Can't write listing file:
    cannot write the list file
Can't write label file:
    cannot write the label file
File recursion
    wrong use of .include
Macro recursion too deep
    wrong use of nested macros
Unknown CPU
    CPU type not known
Ooops! Too many passes...
    With a carefuly crafted source file it's possible to create unresolvable
    situations. Fix your code.

-------------------------------------------------------------------------------

Standard 6502 opcodes

The standard 6502 opcodes:

ADC $61, $65, $69, $6D, $71, $75, $79, $7D
AND $21, $25, $29, $2D, $31, $35, $39, $3D
ASL $06, $0A, $0E, $16, $1E
BCC $90
BCS $B0
BEQ $F0
BIT $24, $2C
BMI $30
BNE $D0
BPL $10
BRK $00
BVC $50
BVS $70
CLC $18
CLD $D8
CLI $58
CLV $B8
CMP $C1, $C5, $C9, $CD, $D1, $D5, $D9, $DD
CPX $E0, $E4, $EC
CPY $C0, $C4, $CC
DEC $C6, $CE, $D6, $DE
DEX $CA
DEY $88
EOR $41, $45, $49, $4D, $51, $55, $59, $5D
INC $E6, $EE, $F6, $FE
INX $E8
INY $C8
JMP $4C, $6C
JSR $20
LDA $A1, $A5, $A9, $AD, $B1, $B5, $B9, $BD
LDX $A2, $A6, $AE, $B6, $BE
LDY $A0, $A4, $AC, $B4, $BC
LSR $46, $4A, $4E, $56, $5E
NOP $EA
ORA $01, $05, $09, $0D, $11, $15, $19, $1D
PHA $48
PHP $08
PLA $68
PLP $28
ROL $26, $2A, $2E, $36, $3E
ROR $66, $6A, $6E, $76, $7E
RTI $40
RTS $60
SBC $E1, $E5, $E9, $ED, $F1, $F5, $F9, $FD
SEC $38
SED $F8
SEI $78
STA $81, $85, $8D, $91, $95, $99, $9D
STX $86, $8E, $96
STY $84, $8C, $94
TAX $AA
TAY $A8
TSX $BA
TXA $8A
TXS $9A
TYA $98

Aliases, pseudo instructions:

BGE $B0
BLT $90
GCC $4C, $90
GCS $4C, $B0
GEQ $4C, $F0
GGE $4C, $B0
GLT $4C, $90
GMI $30, $4C
GNE $4C, $D0
GPL $10, $4C
GVC $4C, $50
GVS $4C, $70

-------------------------------------------------------------------------------

6502 illegal opcodes

The standard 6502 opcodes, plus additionally:

ANC $0B
ANE $8B
ARR $6B
ASR $4B
DCP $C3, $C7, $CF, $D3, $D7, $DB, $DF
ISB $E3, $E7, $EF, $F3, $F7, $FB, $FF
JAM $02
LAX $A3, $A7, $AB, $AF, $B3, $B7, $BF
LDS $BB
NOP $04, $0C, $14, $1C, $80
RLA $23, $27, $2F, $33, $37, $3B, $3F
RRA $63, $67, $6F, $73, $77, $7B, $7F
SAX $83, $87, $8F, $97
SBX $CB
SHA $93, $9F
SHS $9B
SHX $9E
SHY $9C
SLO $03, $07, $0F, $13, $17, $1B, $1F
SRE $43, $47, $4F, $53, $57, $5B, $5F

Additional aliases:

AHX $93, $9F
ALR $4B
AXS $CB
DCM $C3, $C7, $CF, $D3, $D7, $DB, $DF
INS $E3, $E7, $EF, $F3, $F7, $FB, $FF
ISC $E3, $E7, $EF, $F3, $F7, $FB, $FF
LAE $BB
LAS $BB
LXA $AB
TAS $9B
XAA $8B

-------------------------------------------------------------------------------

65DTV02 opcodes

Additionally to 6502 illegal opcodes:

BRA $12
SAC $32
SIR $42

Additional pseudo instruction:

GRA $12, $4C

These illegal opcodes are not valid:

ANC $0B
JAM $02
LDS $BB
NOP $04, $0C, $14, $1C, $80
SBX $CB
SHA $93, $9F
SHS $9B
SHX $9E
SHY $9C

These illegal aliases are not valid:

AHX $93, $9F
AXS $CB
LAE $BB
LAS $BB
TAS $9B

-------------------------------------------------------------------------------

Standard 65C02 opcodes

Additional opcodes to standard 6502:

ADC $72
AND $32
BIT $34, $3C, $89
BRA $80
CMP $D2
DEC $3A
EOR $52
INC $1A
JMP $7C
LDA $B2
ORA $12
PHX $DA
PHY $5A
PLX $FA
PLY $7A
SBC $F2
STA $92
STZ $64, $74, $9C, $9E
TRB $14, $1C
TSB $04, $0C

Additional aliases and pseudo instructions:

DEA $3A
GRA $4C, $80
INA $1A

-------------------------------------------------------------------------------

R65C02 opcodes

Additional opcodes to standard 65C02:

BBR $0F, $1F, $2F, $3F, $4F, $5F, $6F, $7F
BBS $8F, $9F, $AF, $BF, $CF, $DF, $EF, $FF
RMB $07, $17, $27, $37, $47, $57, $67, $77
SMB $87, $97, $A7, $B7, $C7, $D7, $E7, $F7

-------------------------------------------------------------------------------

W65C02 opcodes

Additional opcodes to R65C02:

STP $DB
WAI $CB

-------------------------------------------------------------------------------

W65816 opcodes

Additional opcodes to standard 65C02:

ADC $63, $67, $6F, $73, $77, $7F
AND $23, $27, $2F, $33, $37, $3F
BRL $82
CMP $C3, $C7, $CF, $D3, $D7, $DF
COP $02
EOR $43, $47, $4F, $53, $57, $5F
JMP $5C, $DC
JSL $22
JSR $FC
LDA $A3, $A7, $AF, $B3, $B7, $BF
MVN $54
MVP $44
ORA $03, $07, $0F, $13, $17, $1F
PEA $F4
PEI $D4
PER $62
PHB $8B
PHD $0B
PHK $4B
PLB $AB
PLD $2B
REP $C2
RTL $6B
SBC $E3, $E7, $EF, $F3, $F7, $FF
SEP $E2
STA $83, $87, $8F, $93, $97, $9F
STP $DB
SWA $EB
TAD $5B
TAS $1B
TCD $5B
TCS $1B
TDA $7B
TDC $7B
TSA $3B
TSC $3B
TXY $9B
TYX $BB
XBA $EB
XCE $FB
WAI $CB

Additional aliases:

JML $5C, $DC

-------------------------------------------------------------------------------

65EL02 opcodes

Additional opcodes to standard 65C02:

ADC $63, $67, $73, $77
AND $23, $27, $33, $37
CMP $C3, $C7, $D3, $D7
DIV $4F, $5F, $6F, $7F
ENT $22
EOR $43, $47, $53, $57
JSR $FC
LDA $A3, $A7, $B3, $B7
MMU $EF
MUL $0F, $1F, $2F, $3F
NXA $42
NXT $02
ORA $03, $07, $13, $17
PEA $F4
PEI $D4
PER $62
PHD $DF
PLD $CF
REA $44
REI $54
REP $C2
RER $82
RHA $4B
RHI $0B
RHX $1B
RHY $5B
RLA $6B
RLI $2B
RLX $3B
RLY $7B
SBC $E3, $E7, $F3, $F7
SEA $9F
SEP $E2
STA $83, $87, $93, $97
STP $DB
SWA $EB
TAD $BF
TDA $AF
TIX $DC
TRX $AB
TXI $5C
TXR $8B
TXY $9B
TYX $BB
WAI $CB
XBA $EB
XCE $FB
ZEA $8F

