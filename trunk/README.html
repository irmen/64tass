<!DOCTYPE HTML>
<html>
<head>
<title>64tass v1.5x manual</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="Author" content="Kajtar Zsolt">
<style type="text/css">
dt {margin-top:0.5em}
dt + dt {margin-top:0em}
dl.dir dt {font-family:monospace}
legend {font-family:sans;padding-left:1ex;padding-right:1ex}
fieldset {border:1px solid silver}
fieldset pre {margin:0px;}
body {width:50em;}
h1, h2, h3, h4, h5 {font-family:sans}
hr {border: 1pt solid black;background:black;}
pre b {color:navy;}
pre b.d {color:orange;}
pre b.k {color:blue;}
pre span {color:#e00000;}
pre span.s {color:orange;}
pre i {color:brown;}
pre span.l {color:green;}
p {text-align:justify}
</style>
</head>
<body>
<h1>64tass v1.5x manual</h1>

<p>Original written for DOS by Marek Matula of Taboo, then ported to ansi C by
BigFoot/Breeze, and finally added 65816 support, DTV, illegal opcodes,
optimizations, multi pass compile and a lot of features by Soci/Singular.
Improved TASS compatibility, PETSCII codes by Groepaz.</p>

<p>Additional code: my_getopt command-line argument parser by Benjamin
Sittler, avl tree code by Franck Bui-Huu, ternary tree code by Daniel
Berlin.</p>

<p>Syntax is the same as the well known Turbo Assembler on c64, so you can
port your sources easy by only replacing the CR at the end of each line.</p>

<p>Maintainer: soci at c64.rulez.org</p>

<p><b>This is a development version, features or syntax may change over time.
Not everything is backwards compatible.</b></p>

<hr>
<h2>Usage tips</h2>
<p>64tass is a command line compiler, the source can be written in any text editor.
As a minimum the source filename must be given on command line.</p>
<pre>
64tass src.asm
</pre>
<p>There are also some useful parameters which are described later.</p>
<p>For comfortable compiling I use such <q>Makefile</q>s (for <a href="http://en.wikipedia.org/wiki/Make_%28software%29">make</a>):</p>
<pre>
demo.prg: source.asm makros.asm pic.drp music.bin
	64tass -C -a -B -i source.asm -o demo.tmp
        pucrunch -ffast -x 2048 demo.tmp &gt;demo.prg
</pre>
<p>This way <q>demo.prg</q> is recreated by compiling <q>source.asm</q>
whenever <q>source.asm</q>, <q>makros.asm</q>, <q>pic.drp</q> or <q>music.bin</q> had changed.</p>
<p>Of course it's not much harder to create something similar for win32 (make.bat),
however this will always compile and compress:</p>
<pre>
64tass.exe -C -a -B -i source.asm -o demo.tmp
pucrunch.exe -ffast -x 2048 demo.tmp &gt;demo.prg
</pre>
<p>Here's a slightly more advanced Makefile example with default action as
testing in VICE, clean target for removal of temporary files and compressing
using an intermediate temporary file:</p>
<pre>
all: demo.prg
	x64 -autostartprgmode 1 -autostart-warp +truedrive +cart $&lt;

demo.prg: demo.tmp
	pucrunch -ffast -x 2048 $&lt; &gt;$@

demo.tmp: source.asm makros.asm pic.drp music.bin
	64tass -C -a -B -i $&lt; -o $@

.INTERMEDIATE: demo.tmp
.PHONY: all clean
clean:
	$(RM) demo.prg demo.tmp
</pre>
<p>Another useful thing is to add a basic header to your source files
like the one below, so that the resulting file is directly runnable
without additional compression:</p>
<pre>
        <b>*=</b> <span>$0801</span>
        <b class="d">.word</b> (<span class="l">+</span>), <span>2005</span>   <i>;pointer, line number</i>
        <b class="d">.null</b> <span>$9e</span>, ^<span class="l">start</span><i>;will be sys 4096</i>
+	<b class="d">.word</b> <span>0</span>          <i>;basic line end</i>

        <b>*=</b> <span>$1000</span>

start	<b>rts</b>
</pre>

<p>A frequently comming up question is, how to automatically allocate
memory, without hacks like <code>*=*+1</code>? Sure
there's <code>.byte</code> and friends for variables with initial values
but what about zero page, or RAM outside of program area? The solution
is to not use an initial value by using '<code>?</code>' or not
giving a fill byte value to <code>.fill</code>.</p>
<pre>
        <b>*=</b> <span>$02</span>
p1	<b class="d">.word</b> <span>?</span>         <i>;a zero page pointer</i>
temp	<b class="d">.fill</b> <span>10</span>        <i>;a 10 byte temporary area</i>
</pre>
<p>Space allocated this way
is not saved in the output as there's no data to save at those
addresses.</p>
<p>What about some code running on zero page for speed? It needs to be
relocated, and the length must be known to copy it there. Here's
an example:</p>
<pre width=80>
        <b>ldx</b> #size(<span class="l">zpcode</span>)-<span>1</span><i>;calculate length</i>
-       <b>lda</b> <span class="l">zpcode</span>,x
        <b>sta</b> <span class="l">wrbyte</span>,x
        <b>dex</b>             <i>;install to zeropage</i>
        <b>bpl</b> <span class="l">-</span>
        <b>jsr</b> <span class="l">wrbyte</span>
        <b>rts</b>
<i>;code continues here but is compiled to run from $02</i>
zpcode  <b class="k">.logical</b> <span>$02</span>
wrbyte  <b>sta</b> <span>$ffff</span>       <i>;quick byte writer at $02</i>
        <b>inc</b> <span class="l">wrbyte</span>+<span>1</span>
        <b>bne</b> <span class="l">+</span>
        <b>inc</b> <span class="l">wrbyte</span>+<span>2</span>
+	<b>rts</b>
	<b class="k">.here</b>
</pre>

<p>For writing short code there are some special pseudo instructions for always
taken branches. These are automatically compiled as relative branches when the
jump distance is short enough and as <code>JMP</code> or <code>BRL</code> when
longer. The names are derived from conditional branches and are:
<code>GEQ</code>, <code>GNE</code>, <code>GCC</code>, <code>GCS</code>,
<code>GPL</code>, <code>GMI</code>, <code>GVC</code>, and <code>GVS</code>.</p>

<p>There's one more called <code>GRA</code> for CPUs supporting
<code>BRA</code>, which is expanded to <code>BRL</code> (if available) or
<code>JMP</code>.</p>

<pre>
.0000    a9 03          lda #$03        in1     <b>lda</b> #<span>3</span>
.0002    d0 02          gne $0006               <b>gne</b> <span class="l">at</span>          <i>;branch always</i>
.0004    a9 02          lda #$02        in2     <b>lda</b> #<span>2</span>
.0006    4c 00 10       gne $1000       at      <b>gne</b> <span>$1000</span>       <i>;branch further</i>
</pre>

<p>If the branch would skip only one byte then the opposite condition is compiled
and only the first byte is emitted. This is now a never executed jump, and the
relative distance byte after the opcode is the jumped over byte.</p>

<p>If the branch would not skip anything at all then no code is generated.</p>

<pre>
.0009                   geq $0009               <b>geq</b> <span class="l">in3</span>         <i>;zero length "branch"</i>
.0009    18             clc             in3     <b>clc</b>
.000a    b0             gcc $000c               <b>gcc</b> <span class="l">at2</span>         <i>;one byte skip, as bcs</i>
.000b    38             sec             in4     <b>sec</b>             <i>;sec is skipped!</i>
.000c    20 0f 00       jsr $000f       at2     <b>jsr</b> <span class="l">func</span>
.000f                                   func
</pre>

<p>Please note that expressions like <code>Gxx *+2</code> or <code>Gxx
*+3</code> are not allowed as the compiler can't figure out if it has to create
no code at all, the 1 byte variant or the 2 byte one. Therefore use normal or
anonymous labels defined after the jump instruction when jumping forward!</p>

<p>To avoid branch too long errors the assembler also supports long branches,
it can automatically convert conditional relative branches to it's opposite and
a <code>JMP</code> or <code>BRL</code>. This can be enabled on the command
line using the <q>--long-branch</q> option.</p>

<pre>
.0000    ea             nop                     <b>nop</b>
.0001    b0 03 4c 00 10 bcc $1000               <b>bcc</b> <span>$1000</span>      <i>;long branch</i>
.0006    ea             nop                     <b>nop</b>
</pre>

<p>Please note that forward jump expressions like <code>Bxx *+130</code>,
<code>Bxx *+131</code> and <code>Bxx *+132</code> are not allowed as the
compiler can't decide between a short/long branch. Of course these destinations
can be used, but only with normal or anonymous labels defined after the jump
instruction.</p>

<p>There are some other tips below in the descriptions.</p>

<hr>
<h2>Command line options</h2>

<h3>Output options</h3>

<dl class="dir">
<dt><b>-o</b> &lt;filename&gt;
<dd>Place output into &lt;filename&gt;
<p>The default output filename is <q>a.out</q>. This option changes it.</p>
<fieldset>
<legend>Example</legend>
<pre>
64tass a.asm -o a.prg
</pre>
</fieldset>

<dt><b>-b</b>, <b>--nostart</b>
<dd>Strip starting address
<p>Strips the 2 or 3 byte starting address before the resulting binary.
Useful for creating small ROM images.</p>

<dt><b>-f</b>, <b>--flat</b>
<dd>Flat output mode
<p>Output the plain binary image from offset 0. The image size can be much larger than
the processor address space. Useful for creating huge multi bank ROM files.</p>

<dt><b>-n</b>, <b>--nonlinear</b>
<dd>Generate nonlinear output file
<p>Generates non-linear output for linkers.
Format: length, address, code, length, ...</p>
<fieldset>
<legend>Example</legend>
<pre>
64tass --nonlinear a.asm
        <b>*=</b> <span>$1000</span>
        <b>lda</b> #<span>2</span>
        <b>*=</b> <span>$2000</span>
	<b>nop</b>
result:
$02, $00 ;little endian length, 2 bytes
$00, $10 ;little endian start $1000
$a9, $02 ;code
$01, $00 ;little endian length, 1 byte
$00, $20 ;little endian start $2000
$ea	 ;code
$00, $00 ;end marker (length=0)
</pre>
</fieldset>

<dt><b>-W</b>, <b>--wordstart</b>
<dd>Force 2 byte start address
<p>If 16&nbsp;MiB address space is used for a 65816, then the starting
address of file will be 3 bytes long. This option makes it 2 bytes long.</p>
<fieldset>
<legend>Example</legend>
<pre>
64tass --wordstart --m65816 a.asm
</pre>
</fieldset>

</dl>

<h3>Operation options</h3>

<dl class="dir">
<dt><b>-a</b>, <b>--ascii</b>
<dd>Use ASCII/Unicode text encoding instead of raw 8-bit
<p>Normally no conversion takes place, this is for backwards compatibility with
a DOS based Turbo Assembler editor, which could create PETSCII files for
6502tass. (including control characters of course)</p>
<p>Using this option will change the default <q>none</q> and <q>screen</q> encodings to
map 'a'-'z' and 'A'-'Z' into the correct PETSCII range of $41-$5A and $C1-$DA,
which is more suitable for an ASCII editor. It also adds predefined petcat style
PETASCII literals to the default encodings.</p>
<p><b>For writing sources in utf8/utf16 encodings this option is required!</b> The
symbol names are still limited to ASCII, but custom string encodings can take
advantage of the full unicode set.</p>
<fieldset>
<legend>Example</legend>
<pre>
64tass a.asm

.0000    a9 61          lda #$61        <b>lda</b> #<span class="s">"a"</span>

&gt;0002    31 61 41                       <b class="d">.text</b> <span class="s">"1aA"</span>
&gt;0005    7b 63 6c 65 61 72 7d 74        <b class="d">.text</b> <span class="s">"{clear}text{return}more"</span>
&gt;000e    65 78 74 7b 72 65 74 75
&gt;0016    72 6e 7d 6d 6f 72 65

64tass --ascii a.asm

.0000    a9 41          lda #$41        <b>lda</b> #<span class="s">"a"</span>
&gt;0002    31 41 c1                       <b class="d">.text</b> <span class="s">"1aA"</span>
&gt;0005    93 54 45 58 54 0d 4d 4f        <b class="d">.text</b> <span class="s">"<span>{clear}</span>text<span>{return}</span>more"</span>
&gt;000e    52 45
</pre>
</fieldset>

<dt><b>-B</b>, <b>--long-branch</b>
<dd>Automatic <code>BXX *+5 JMP xxx</code>
<p>Branch too long messages can be annoying sometimes, usually they'll result
in an <code>BXX *+5 JMP xxx</code> rewrite. 64tass can do this automatically if this option is
used. But <code>BRA</code> is not converted.</p>
<fieldset>
<legend>Example</legend>
<pre>
64tass a.asm
        <b>*=</b> <span>$1000</span>
        <b>bcc</b> <span>$1233</span>	<i>;error...</i>

64tass a.asm
        <b>*=</b> <span>$1000</span>
        <b>bcs</b> *+<span>5</span>		<i>;opposite condition</i>
        <b>jmp</b> <span>$1233</span>	<i>;as simple workaround</i>

64tass --long-branch a.asm
        <b>*=</b> <span>$1000</span>
        <b>bcc</b> <span>$1233</span>	<i>;no error, automatically converted to the above one.</i>
</pre>
</fieldset>

<dt><b>-C</b>, <b>--case-sensitive</b>
<dd>Case sensitive labels
<p>Labels are non case sensitive by default, this option changes that.</p>
<fieldset>
<legend>Example</legend>
<pre>
64tass a.asm
label	<b>nop</b>
Label	<b>nop</b>	<i>;double defined...</i>

64tass --case-sensitive a.asm
label   <b>nop</b>
Label	<b>nop</b>	<i>;Ok, it's a different label...</i>
</pre>
</fieldset>

<dt><b>-D</b> &lt;label&gt;=&lt;value&gt;
<dd>Define &lt;label&gt; to &lt;value&gt;
<p>Defines a label to a value. Same syntax is allowed as in source files. Be careful with
string quoting, the shell might eat some of the characters.</p>
<fieldset>
<legend>Example</legend>
<pre>
64tass -D ii=2 a.asm
        <b>lda</b> #<span class="l">ii</span> <i>;result: $a9, $02</i>
</pre>
</fieldset>

<dt><b>-w</b>, <b>--no-warn</b>
<dd>Suppress warnings
<p>Disables warnings during compile.</p>
<fieldset>
<legend>Example</legend>
<pre>
64tass --no-warn a.asm
</pre>
</fieldset>

<dt><b>-q</b>, <b>--quiet</b>
<dd>Suppress messages
<p>Disables header and summary messages.</p>
<fieldset>
<legend>Example</legend>
<pre>
64tass --quiet a.asm
</pre>
</fieldset>

<dt><b>-T</b>, <b>--tasm-compatible</b>
<dd>Enable TASM compatible operators and precedence
<p>Switches the expression evaluator into compatibility mode. This
enables <q>.</q>, <q>:</q> and <q>!</q> operators and disables 64tass specific extensions, disables precedence handling
and forces 16&nbsp;bit unsigned evaluation (see <q>differences to original Turbo Assembler</q> below)</p>

<dt><b>-I</b> &lt;path&gt;
<dd>Specify include search path
<p>If an included source or binary file can't be found in the directory of the
source file then this path is tried. More than one directories can be specified
by repeating this option. If multiple matches exist the first one is used.</p>
</dl>

<h3>Target selection on command line</h3>
<p>These options will select the default architecture. It can be overridden by
using the <code>.cpu</code> directive in the source.</p>

<dl class="dir">
<dt><b>--m65xx</b>
<dd>Standard 65xx (default)
<p>Selects standard 6502. For writing compatible code, no extra codes. This is the default.</p>
<fieldset>
<legend>Example</legend>
<pre>
64tass --m65xx a.asm
        <b>lda</b> <span>$14</span>		<i>;regular instructions</i>
</pre>
</fieldset>

<dt><b>-c</b>, <b>--m65c02</b>
<dd>CMOS 65C02
<p>Selects 65c02. Enables extra opcodes and addressing modes specific to this CPU.</p>
<fieldset>
<legend>Example</legend>
<pre>
64tass --m65c02 a.asm
        <b>stz</b> <span>$d020</span>	<i>;65c02 instruction</i>
</pre>
</fieldset>

<dt><b>-c</b>, <b>--m65ce02</b>
<dd>CSG 65CE02
<p>Selects 65ce02. Enables extra opcodes and addressing modes specific to this CPU.</p>
<fieldset>
<legend>Example</legend>
<pre>
64tass --m65ce02 a.asm
        <b>inz</b>
</pre>
</fieldset>

<dt><b>-i</b>, <b>--m6502</b>
<dd>NMOS 65xx
<p>Selects NMOS 6502. Enables extra illegal opcodes. Useful for demo coding for C64, disk drive code, etc.</p>
<legend>Example</legend>
<fieldset>
<pre>
64tass --m6502 a.asm
        <b>lax</b> <span>$14</span>		<i>;illegal instruction</i>
</pre>
</fieldset>

<dt><b>-t</b>, <b>--m65dtv02</b>
<dd>65DTV02
<p>Selects 65DTV02. Enables extra opcodes specific to DTV.</p>
<fieldset>
<legend>Example</legend>
<pre>
64tass --m65dtv02 a.asm
        <b>sac</b> #<span>$00</span>
</pre>
</fieldset>

<dt><b>-x</b>, <b>--m65816</b>
<dd>W65C816
<p>Selects 65816. Enables extra opcodes, and full 16&nbsp;MiB address space.
Useful for SuperCPU projects. Don't forget to use <q>--word-start</q> for small ones ;)</p>
<fieldset>
<legend>Example</legend>
<pre>
64tass --m65816 a.asm
        <b>lda</b> <span>$123456</span>,x
</pre>
</fieldset>

<dt><b>-e</b>, <b>--m65el02</b>
<dd>65EL02
<p>Selects 65EL02. Enables extra opcodes, useful <a href="http://www.eloraam.com/nonwp/redcpu.php">RedPower CPU</a> projects. Probably you'll need <q>--nostart</q> as well.</p>
<fieldset>
<legend>Example</legend>
<pre>
64tass --m65el02 a.asm
        <b>lda</b> <span>0</span>,r
</pre>
</fieldset>

<dt><b>--mr65c02</b>
<dd>R65C02
<p>Selects r65c02. Enables extra opcodes and addressing modes specific to this CPU.</p>
<fieldset>
<legend>Example</legend>
<pre>
64tass --mr65c02 a.asm
        <b>rmb</b> <span>7</span>,<span>$20</span>
</pre>
</fieldset>

<dt><b>--mw65c02</b>
<dd>W65C02
<p>Selects w65c02. Enables extra opcodes and addressing modes specific to this CPU.</p>
<fieldset>
<legend>Example</legend>
<pre>
64tass --mw65c02 a.asm
        <b>wai</b>
</pre>
</fieldset>
</dl>

<h3>Source listing options</h3>

<dl class="dir">
<dt><b>-l</b> &lt;file&gt;
<dd>List labels into &lt;file&gt;
<p>List global labels to a file. Unused ones are marked with a comment.</p>
<fieldset>
<legend>Example</legend>
<pre>
64tass -l labels.txt a.asm
        <b>*=</b> <span>$1000</span>
label

result (labels.txt):
label           = $1000    ; *** unused
</pre>
</fieldset>

<dt><b>-L</b> &lt;file&gt;
<dd>List into &lt;file&gt;
<p>Dumps source code and compiled code into file. Useful for debugging,
it's much easier to identify the code in memory within the source files.</p>
<fieldset>
<legend>Example</legend>
<pre>
64tass -L list.txt a.asm
        <b>*=</b> <span>$1000</span>
        <b>ldx</b> #<span>0</span>
loop	<b>dex</b>
        <b>bne</b> <span class="l">loop</span>
	<b>rts</b>

result (list.txt):

;64tass Turbo Assembler Macro V1.5x listing file of "a.asm"
;done on Fri Dec  9 19:08:55 2005


.1000	 a2 00		ldx #$00		ldx #0
.1002	 ca		dex		loop	dex
.1003	 d0 fd		bne $1002		bne loop
.1005	 60		rts			rts

;******  end of code
</pre>
</fieldset>

<dt><b>-m</b>, <b>--no-monitor</b>
<dd>Don't put monitor code into listing
<p>There won't be any monitor listing in the list file.</p>
<fieldset>
<legend>Example</legend>
<pre>
64tass --no-monitor -L list.txt a.asm

result (list.txt):

;64tass Turbo Assembler Macro V1.5x listing file of "a.asm"
;done on Fri Dec  9 19:11:43 2005


.1000	 a2 00					ldx #0
.1002	 ca				loop	dex
.1003	 d0 fd					bne loop
.1005	 60					rts

;******  end of code
</pre>
</fieldset>

<dt><b>-s</b>, <b>--no-source</b>
<dd>Don't put source code into listing
<p>There won't be any source listing in the list file.</p>
<fieldset>
<legend>Example</legend>
<pre>
64tass --no-source -L list.txt a.asm

result (list.txt):

;64tass Turbo Assembler Macro V1.5x listing file of "a.asm"
;done on Fri Dec  9 19:13:25 2005


.1000	 a2 00		ldx #$00
.1002	 ca		dex
.1003	 d0 fd		bne $1002
.1005	 60		rts

;******  end of code
</pre>
</fieldset>
</dl>

<h3>Other options</h3>

<dl class="dir">
<dt><b>-?</b>, <b>--help</b>
<dd>Give this help list
<p>Prints help about command line options.</p>

<dt><b>--usage</b>
<dd>Give a short usage message
<p>Prints short help about command line options.</p>

<dt><b>-V</b>, <b>--version</b>
<dd>Print program version
<p>Prints program version.</p>
</dl>

<hr>

<h2>Labels</h2>

<p>Normal labels can be defined at the start of each line and hold the logical
address of that line, or the value after the equal sign. Each of them is uniq and
can't be redefined. Labels can be forward referenced, the assembler will make as
many passes as required to resolve them to a stable value.</p>

<pre width=80>
reg	<b>=</b> <span>$d020</span>

loop
        <b>inc</b> <span class="l">reg</span>
        <b>jmp</b> <span class="l">loop</span>
</pre>

<h3>Variables</h3>

<p>Variables are redefinable, and as their value will be non stable forward referencing is not allowed.</p>

<pre width=80>
variabl	<b class="k">.var</b> <span>1</span>
        <b class="k">.rept</b> <span>10</span>
        <b class="d">.byte</b> <span class="l">variabl</span>
variabl	<b class="k">.var</b> <span class="l">variabl</span>+<span>1</span>
	<b class="k">.next</b>
</pre>

<h3>Anonymous labels</h3>
<p>The assembler supports anonymous labels, also called as forward (<tt>+</tt>) and backward (<tt>-</tt>) references.
<q><tt>-</tt></q> means one backward, <q><tt>--</tt></q> means two backward, etc. also the same for forward, but with <q><tt>+</tt></q>.
</p>
<pre width=80>
        <b>ldy</b> #<span>4</span>
-       <b>ldx</b> #<span>0</span>
-       <b>txa</b>
        <b>cmp</b> #<span>3</span>
	<b>bcc</b> +
        <b>adc</b> #<span>44</span>
+       <b>sta</b> <span>$400</span>,x
	<b>inx</b>
	<b>bne</b> -
	<b>dey</b>
	<b>bne</b> --
</pre>
<p>These references are also useful in segments, but this can create a nice traps, as segments are
copied into the code, with the internal references.
</p>
<pre>
	<b>bne</b> +
	#somemakro      <i>;let's hope that this segment does</i>
+	<b>nop</b>             <i>;not contain forward references...</i>
</pre>

<h2>Expressions</h2>

<p>Numeric constants of decimal (<code>0-9</code>), hexadecimal
(<code>$</code>) and binary (<code>%</code>) are accepted. String constants are 
enclosed in quotation marks. To enter the quotation mark itself in the string
just double it. Single letter strings are character constants and represent their
numeric values in numeric expressions.</p>

<pre width=80>
        <b class="d">.byte</b> <span>23</span>        <i>; decimal</i>
        <b class="d">.byte</b> <span>$33</span>       <i>; hex</i>
        <b class="d">.byte</b> <span>%00011111</span> <i>; binary</i>
        <b class="d">.byte</b> <span>3.4</span>       <i>; real</i>

        <b class="d">.text</b> <span class="s">"oeU"</span>     <i>; text</i>
        <b class="d">.text</b> <span class="s">'it''s'</span>   <i>; text: it's</i>
</pre>

<p>Parenthesis (<code>( )</code>) and brackets (<code>[ ]</code>) can be
used to override operator precedence. Don't forget that they also
denote indirect addressing mode for certain opcodes.</p>

<pre width=80>
        <b>lda</b> #(<span>4</span>+<span>2</span>)*<span>3</span>
</pre>

<p>The dot (<code>.</code>) operator can be used to reference
member elements of structs and unions.</p>

<pre width=80>
        <b>lda</b> <span class="l">storage</span>.<span class="l">len</span>
</pre>

<!--<p>Brackets (<code>[</code> <code>]</code>) operator can be used to reference
member elements of arrays by their address. Indexing starts at 0.</p>

<pre width=80>
        <b>lda</b> <span class="l">myarr</span>[<span>2</span>],y
        <b>ldx</b> <span class="l">myarr</span>[<span>2</span>]+<span>1</span>,y
myarr   <b class="d">.word</b> <span>542</span>,<span>722</span>,<span>373</span>,<span>443</span>
</pre>-->

<p>Built in functions are identifiers following parentheses. They accept
variable number of parameters separated by comma.</p>

<table border="0">
<tr><td width="150">min(a, b, ...)</td><td>Minimum of values</td></tr>
<tr><td>max(a, b, ...)</td><td>Maximum of values</td></tr>
<tr><td>size(a)</td><td>Size of structure in bytes</td></tr>
<tr><td>len(a)</td><td>Length of list, characters in string</td></tr>
<tr><td>abs(a)</td><td>Absolute value</td></tr>
<tr><td>sign(a)</td><td>Sign value (-1, 0, 1)</td></tr>
<tr><td>floor(a)</td><td>Round down</td></tr>
<tr><td>round(a)</td><td>Round to nearest away from zero</td></tr>
<tr><td>ceil(a)</td><td>Round up</td></tr>
<tr><td>trunc(a)</td><td>Round down towards zero</td></tr>
<tr><td>frac(a)</td><td>Fractional part</td></tr>
<tr><td>sqrt(a)</td><td>Square root</td></tr>
<tr><td>cqrt(a)</td><td>Cube root</td></tr>
<tr><td>log10(a)</td><td>Common logarithm</td></tr>
<tr><td>log(a)</td><td>Natural logarithm</td></tr>
<tr><td>exp(a)</td><td>Exponential</td></tr>
<tr><td>pow(a, b)</td><td>a raised to power of b</td></tr>
<tr><td>sin(a)</td><td>Sine</td></tr>
<tr><td>asin(a)</td><td>Arc sine</td></tr>
<tr><td>sinh(a)</td><td>Hyperbolic sine</td></tr>
<tr><td>cos(a)</td><td>Cosine</td></tr>
<tr><td>acos(a)</td><td>Arc cosine</td></tr>
<tr><td>cosh(a)</td><td>Hyperbolic cosine</td></tr>
<tr><td>tan(a)</td><td>Tangent</td></tr>
<tr><td>atan(a)</td><td>Arc tangent</td></tr>
<tr><td>tanh(a)</td><td>Hyperbolic tangent</td></tr>
<tr><td>rad(a)</td><td>Degrees to radian</td></tr>
<tr><td>deg(a)</td><td>Radian to degrees</td></tr>
<tr><td>hypot(y, x)</td><td>Polar distance</td></tr>
<tr><td>atan2(y, x)</td><td>Polar angle</td></tr>
</table>

<p>There are no predefined math constants, but as a hint pi is <code>rad(180)</code>
and e is <code>exp(1)</code>.</p>

<p>Single bytes or words of numeric values can be extracted
by the following operators:</p>

<table border="0">
<tr><td width="80"><tt>&lt;</tt><td align="left">lower byte (bits 0..7)
<tr><td><tt>&gt;</tt><td align="left">higher byte (bits 8..15)
<tr><td><tt>`</tt><td align="left">bank byte (bits 16..23)
<tr><td><tt>&lt;&gt;</tt><td align="left">lower word (bits 0..15)
<tr><td><tt>&gt;`</tt><td align="left">higher word (bits 8..23)
<tr><td><tt>&gt;&lt;</tt><td align="left">lower byte swapped word (bits 0..15)
</table>

<pre width=80>
        <b>lda</b> #&lt;<span class="l">label</span>
        <b>ldy</b> #&gt;<span class="l">label</span>
        <b>jsr</b> <span>$ab1e</span>

        <b>ldx</b> #&lt;&gt;<span class="l">source</span>
        <b>ldy</b> #&lt;&gt;<span class="l">dest</span>
        <b>lda</b> #size(<span class="l">source</span>)-1
        <b>mvn</b> `<span class="l">source</span>, `<span class="l">dest</span>
</pre>

<p>Special addressing mode forcing operators in front of an expression can be
used to make sure the expected addressing mode is used.</p>

<table border="0">
<tr><td width="80"><tt>@b</tt><td align="left">to force 8 bit address
<tr><td><tt>@w</tt><td align="left">to force 16 bit address
<tr><td><tt>@l</tt><td align="left">to force 24 bit address (65816)
</table>

<pre width=80>
        <b>lda</b> @w<span>$0000</span>
</pre>

<p>Boolean operators give false (0) or true (1) or one of the operands as the
result. True is defined as a non-zero number, a non-empty string/tupple/list,
anything else is false.</p>

<table border="0">
<tr><td width="80"><tt>x || y</tt><td align="left">if x is true then x otherwise y
<tr><td><tt>x ^^ y </tt><td align="left">if both false or true then false otherwise x || y
<tr><td><tt>x &amp;&amp; y</tt><td align="left">if x is true then y otherwise x
<tr><td><tt>!x</tt><td align="left">if x is true then false otherwise true
</table>

<p>The conditional operator gives the first (x) result if c is true or the second (y) if c is false.</p>

<table border="0">
<tr><td width="80"><tt>c ? x : y</tt><td align="left">ternary
</table>

<p>Comparison operators result in true (1) or false (0) depending on the result.</p>

<table border="0">
<tr><td width="80"><tt>x = y</tt><td align="left">equal
<tr><td><tt>x != y</tt><td align="left">non equal
<tr><td><tt>x &lt; y</tt><td align="left">less
<tr><td><tt>x &gt; y</tt><td align="left">more
<tr><td><tt>x &gt;= y</tt><td align="left">more or equal
<tr><td><tt>x &lt;= y</tt><td align="left">less or equal
</table>

<pre width=80>
        <b class="k">.if</b> <span class="l">ntsc</span>=<span>1</span>
	<b>nop</b>
	<b class="k">.fi</b>
</pre>

<p>There's a variety of bitwise operations available.</p>

<table border="0">
<tr><td width="60"><tt>x | y</tt><td align="left">bitwise or
<tr><td><tt>x ^ y</tt><td align="left">bitwise xor
<tr><td><tt>x &amp; y</tt><td align="left">bitwise and
<tr><td><tt>x &lt;&lt; y</tt><td align="left">logical shift left
<tr><td><tt>x &gt;&gt; y</tt><td align="left">arithmetic shift right
<tr><td><tt>x &gt;&gt;&gt; y</tt><td align="left">logical shift right
<tr><td><tt>~x</tt><td align="left">invert bits
</table>

<pre width=80>
        <b>lda</b> #((<span class="l">bitmap</span> &amp; <span>$2000</span>) &gt;&gt; <span>10</span>) | ((<span class="l">screen</span> &amp; <span>$3c00</span>) &gt;&gt; <span>6</span>)
        <b>sta</b> <span>$d018</span>
        <b>lda</b> <span>$d015</span>
        <b>and</b> #~<span>%00100000</span>
        <b>sta</b> <span>$d015</span>
</pre>

<p>And the regular arithmetic operations are supported as well.</p>

<table border="0">
<tr><td width="60"><tt>x + y</tt><td align="left">add
<tr><td><tt>x - y</tt><td align="left">substract
<tr><td><tt>x * y</tt><td align="left">multiply
<tr><td><tt>x / y</tt><td align="left">divide
<tr><td><tt>x // y</tt><td align="left">modulo
<tr><td><tt>x ** y</tt><td align="left">exponentiation
<tr><td><tt>-x</tt><td align="left">negate
<tr><td><tt>+x</tt><td align="left">unchanged
</table>

<hr>
<h2>Compiler directives:</h2>

<h3>Controlling the program counter</h3>

<p>There are two address counters. One is used for placing the data in memory, the
other one called logical address, and it's what the labels will be set or what
the special star label gets when referenced.</p>

<dl class="dir">
<dt><b>*=</b> &lt;expression&gt;
<dd>Set both compile address and logical address. The compile address is moved so
that the logical address will match at this point. If confused about what this means,
see the example at <code>.logical</code>.
<pre width=80>
        <b>*=</b> <span>$1000</span>
</pre>
<dt><b>.offs</b> &lt;expression&gt;
<dd>Add a compile offset to logical address.
<pre width=80>
        <b class="k">.offs</b> <span>100</span>
</pre>
<dt><b>.logical</b> &lt;expression&gt;
<dt><b>.here</b>
<dd>Changes logical address, compile address is not changed. Can be nested.
<pre width=80>
        <b class="k">.logical</b> <span>$300</span>
drive   <b>lda</b> #<span>$80</span>
        <b>sta</b> <span>$00</span>
        <b>jmp</b> <span class="l">drive</span>       <i>;jmp $300</i>
	<b>rts</b>
	<b class="k">.here</b>
</pre>
<p>Here's an example how <code>.logical</code> and <code>*=</code> works together:</p>
<pre width=80>
        <b>*=</b> <span>$0800</span>       <i>;Compile: $0800, Logical: $0800</i>
        <b class="k">.logical</b> <span>$1000</span> <i>;Compile: $0800, Logical: $1000</i>
        <b>*=</b> <span>$1200</span>       <i>;Compile: $0a00, Logical: $1200</i>
	<b class="k">.here</b>          <i>;Compile: $0a00, Logical: $0a00</i>
</pre>

<dt><b>.align</b> &lt;modulo&gt;[, &lt;fill&gt;]
<dd>Align code to a dividable address by skip or fill
<pre width=80>
        <b class="k">.align</b> <span>$100</span>
irq     <b>inc</b> <span>$d019</span>       ;this will be on a page boundary, after skipping bytes
        <b class="k">.align</b> <span>4</span>, <span>$ea</span>
loop    <b>adc</b> #<span>1</span>          ;padding with "nop" for DTV burst mode
</pre>

</dl>

<h3>Dumping data</h3>
<dl class="dir">
<dt><b>.text</b> &lt;expression&gt;[, &lt;expression&gt;, ...]
<dd>Include constants and strings:
<pre width=80>
        <b class="d">.text</b> <span class="s">"oeU"</span>	<i>; text, "" means $22</i>
        <b class="d">.text</b> <span class="s">'oeU'</span>	<i>; text, '' means $27</i>
        <b class="d">.text</b> <span>23</span>, <span>$33</span>	<i>; bytes</i>
        <b class="d">.text</b> <span>%00011111</span>	<i>; more bytes</i>
        <b class="d">.text</b> ^<span class="l">OEU</span>	<i>; the decimal value as string (^23 is $32,$33)</i>
</pre>

<dt><b>.shift</b> &lt;expression&gt;[, &lt;expression&gt;, ...]
<dd>Same as <code>.text</code>, but the last byte will have the highest bit set.
Any character which already has the most significiant bit set will cause an error.
<pre width=80>
        <b>ldx</b> #<span>0</span>
loop	<b>lda</b> <span class="l">txt</span>,x
	<b>php</b>
        <b>and</b> #<span>$7f</span>
        <b>jsr</b> <span>$ffd2</span>
	<b>inx</b>
	<b>plp</b>
        <b>bpl</b> <span class="l">loop</span>
	<b>rts</b>
txt	<b class="d">.shift</b> <span class="s">"some text"</span>
</pre>

<dt><b>.shiftl</b> &lt;expression&gt;[, &lt;expression&gt;, ...]
<dd>Same as <code>.text</code>, but all bytes are shifted to left, and the last
character gets the lowest bit set. Any character which already has the most significiant
bit set will cause an error as this would be cut off.
<pre width=80>
        <b>ldx</b> #<span>0</span>
loop	<b>lda</b> <span class="l">txt</span>,x
	<b>lsr</b>
        <b>sta</b> <span>$400</span>,x
	<b>inx</b>
        <b>bcc</b> <span class="l">loop</span>
	<b>rts</b>
	<b class="k">.enc</b> screen
txt	<b class="d">.shiftl</b> <span class="s">"some text"</span>
	<b class="k">.enc</b> none
</pre>

<dt><b>.null</b> &lt;expression&gt;[, &lt;expression&gt;, ...]
<dd>Same as <code>.text</code>, but adds a null at the end, null in string is an error.
<pre width=80>
txt	<b class="d">.text</b> <span class="s">"lot of stuff"</span>
        <b class="d">.null</b> <span class="s">"to write"</span>
        <b>lda</b> #&lt;<span class="l">txt</span>
        <b>ldy</b> #&gt;<span class="l">txt</span>
        <b>jsr</b> <span>$ab1e</span>
</pre>

<dt><b>.ptext</b> &lt;expression&gt;[, &lt;expression&gt;, ...]
<dd>Same as <code>.text</code>, but prepend the
number of bytes in front of the string (pascal style string). Longer than 255 bytes are not allowed.
<pre width=80>
        <b>lda</b> #&lt;<span class="l">txt</span>
        <b>ldx</b> #&gt;<span class="l">txt</span>
        <b>jsr</b> <span class="l">print</span>
	<b>rts</b>

print	<b>sta</b> <span>$fb</span>
        <b>stx</b> <span>$fc</span>
        <b>ldy</b> #<span>0</span>
        <b>lda</b> (<span>$fb</span>),y
        <b>beq</b> <span class="l">null</span>
	<b>tax</b>
-	<b>iny</b>
        <b>lda</b> (<span>$fb</span>),y
        <b>jsr</b> <span>$ffd2</span>
	<b>dex</b>
	<b>bne</b> -
null	<b>rts</b>

txt	<b class="d">.ptext</b> <span class="s">"note"</span>
</pre>

<dt><b>.byte</b> &lt;expression&gt;[, &lt;expression&gt;, ...]
<dd>Include 8&nbsp;bit unsigned byte constants
<pre width=80>
        <b class="d">.byte</b> <span>255</span>	<i>; $ff</i>
	<b class="d">.byte</b> ?	        <i>; reserve 1 byte of space</i>
</pre>

<dt><b>.char</b> &lt;expression&gt;[, &lt;expression&gt;, ...]
<dd>Include 8&nbsp;bit signed integer constants
<pre width=80>
        <b class="d">.char</b> -<span>33</span>, <span>57</span>
</pre>

<dt><b>.word</b> &lt;expression&gt;[, &lt;expression&gt;, ...]
<dd>Include 16&nbsp;bit unsigned word constants
<pre width=80>
        <b class="d">.word</b> <span>$2342</span>, <span>$4555</span>
	<b class="d">.word</b> ?	        <i>; reserve 2 bytes of space</i>
</pre>

<dt><b>.int</b> &lt;expression&gt;[, &lt;expression&gt;, ...]
<dd>Include 16&nbsp;bit signed integer constants
<pre width=80>
        <b class="d">.int</b> -<span>533</span>, <span>4433</span>
</pre>

<dt><b>.rta</b> &lt;expression&gt;[, &lt;expression&gt;, ...]
<dd>Include return address constants, which are one byte less than the original.
<pre width=80>
        <b>lda</b> #<span>0</span>
	<b>asl</b>
	<b>tax</b>
        <b>lda</b> <span class="l">rets</span>+<span>1</span>,x
	<b>pha</b>
        <b>lda</b> <span class="l">rets</span>,x
	<b>pha</b>
	<b>rts</b>
rets	<b class="d">.rta</b> <span>$fce2</span>
</pre>

<dt><b>.long</b> &lt;expression&gt;[, &lt;expression&gt;, ...]
<dd>Include 24&nbsp;bit unsigned constants
<pre width=80>
        <b class="d">.long</b> <span>$123456</span>
	<b class="d">.long</b> ?	        <i>; reserve 3 bytes of space</i>
</pre>

<dt><b>.dword</b> &lt;expression&gt;[, &lt;expression&gt;, ...]
<dd>Include 32&nbsp;bit unsigned constants
<pre width=80>
        <b class="d">.dword</b> <span>$12345678</span>
	<b class="d">.dword</b> ?        <i>; reserve 4 bytes of space</i>
</pre>

<dt><b>.dint</b> &lt;expression&gt;[, &lt;expression&gt;, ...]
<dd>Include 32&nbsp;bit signed integer constants
<pre width=80>
        <b class="d">.dint</b> -<span>533</span>, <span>4433</span>
</pre>

<dt><b>.fill</b> &lt;length&gt;[, &lt;fill&gt;]
<dd>Skip bytes, or fill with repeated bytes. For multi byte patterns use <code>.rept</code>!
<pre width=80>
        <b class="d">.fill</b> <span>$100</span>      <i>;no fill, just reserve $100 bytes</i>
        <b class="d">.fill</b> <span>$4000</span>, <span>0</span>  <i>;16384 bytes of 0</i>
</pre>
</dl>

<h3>Text encoding</h3>
64tass supports sources written in utf8, utf16 (be/le) and raw 8-bit encoding. To take
advantage of this capability custom encodings can be defined to map unicode characters
to 8 bit values in strings.
<dl class="dir">
<dt><b>.enc</b> &lt;name&gt;
<dd>Selects text encoding, predefined encodings are <q>none</q> and
<q>screen</q> (screen code), anything else is user defined. All user encodings
start without any character or escape definitions, add some as required.
<pre width=80>
	<b class="k">.enc</b> screen	<i>;screencode mode</i>
        <b class="d">.text</b> <span class="s">"text with screencodes"</span>
        <b>cmp</b> #<span class="s">"u"</span>	<i>;compare screencode</i>
	<b class="k">.enc</b> none	<i>;normal mode again</i>
        <b>cmp</b> #<span class="s">"u"</span>	<i>;compare ascii</i>
</pre>
<dt><b>.cdef</b> &lt;start&gt;, &lt;end&gt;, &lt;coded&gt; [, &lt;start&gt;, &lt;end&gt;, &lt;coded&gt;, ...]
<dt><b>.cdef</b> "&lt;start&gt;&lt;end&gt;", &lt;coded&gt; [, "&lt;start&gt;&lt;end&gt;", &lt;coded&gt;, ...]
<dd>Defines a character range, and assigns all characters one by one from the 8 bit value.
The start and end positions are unicode character codes either by numbers or by typing them.
<dt><b>.edef</b> "&lt;escapetext&gt;", &lt;code&gt; [, "&lt;escapetext&gt;", &lt;code&gt;, ...]
<dd>Defines an escape sequence, and assigns it to a 8 bit value. When using
common prefixes the longest match wins. Useful for defining non-typeable control code aliases.
<pre width=80>
        <b class="k">.enc</b> petscii	<i>;define an ascii->petscii encoding</i>
        <b class="k">.cdef</b> <span class="s">" @"</span>, <span>32</span>  <i>;characters</i>
        <b class="k">.cdef</b> <span class="s">"AZ"</span>, <span>$c1</span>
        <b class="k">.cdef</b> <span class="s">"az"</span>, <span>$41</span>
        <b class="k">.cdef</b> <span class="s">"[["</span>, <span>$5b</span>
        <b class="k">.cdef</b> <span class="s">"&pound;&pound;"</span>, <span>$5c</span>
        <b class="k">.cdef</b> <span class="s">"]]"</span>, <span>$5d</span>
        <b class="k">.cdef</b> <span class="s">"&pi;&pi;"</span>, <span>$5e</span>
        <b class="k">.cdef</b> <span>$2190</span>, <span>$2190</span>, <span>$1f</span><i>;left arrow</i>

        <b class="k">.edef</b> <span class="s">"\n"</span>, <span>13</span>  <i>;escape sequences</i>
        <b class="k">.edef</b> <span class="s">"{clr}"</span>, <span>147</span>

        <b class="d">.text</b> <span class="s">"<span>{clr}</span>Text in PETSCII<span>\n</span>"</span>
</pre>
</dl>

<h3>Structured data</h3>

<p>Structures can be defined to organize sequential data definitions, which can
be reused later many times. The offset of fields are available by using the
definition's name as a base, and the fields themselves by using the instance
name before the dot operator. The length of a struct is the sum of lengths of
all items.</p>

<dl class="dir">
<dt><b>.struct</b>
<dd>Start structure definition
<dt><b>.ends</b>
<dd>Finish structure definition
<dt><b>.dstruct</b> &lt;name&gt;
<dd>Create instance of struct

<pre width=80>
        <b class="k">.struct</b>         <i>;anonymous struct</i>
x       <b class="d">.byte</b> <span>0</span>         <i>;labels are visible</i>
y       <b class="d">.byte</b> <span>0</span>         <i>;content compiled here</i>
        <b class="k">.ends</b>           <i>;useful inside unions</i>

nn_s    <b class="k">.struct</b>         <i>;named struct</i>
x       <b class="d">.byte</b> <span>0</span>         <i>;labels are not visible</i>
y       <b class="d">.byte</b> <span>0</span>         <i>;no content is compiled here</i>
        <b class="k">.ends</b>           <i>;it's just a definition</i>

nn      <b class="d">.dstruct</b> <span class="l">nn_s</span>   <i>;struct instance, content here</i>

        <b>lda</b> <span class="l">nn</span>.<span class="l">x</span>        <i>;access internal fields</i>
        <b>ldy</b> #<span class="l">nn_s</span>.<span class="l">x</span>     <i>;get offset of field</i>
</pre>
</dl>

<p>Unions are similar to structs, except each line will start on the same
address where the definition was done. The length of the union is the length of
it's longest item. The offset of fields are available by using the definition's
name as a base, and the fields themselves by using the instance name before the
dot operator. These offsets and references mostly point to the start of the
union, unless internal anonymous structs are used.</p>

<dl class="dir">
<dt><b>.union</b>
<dd>Start structure definition
<dt><b>.endu</b>
<dd>Finish structure definition
<dt><b>.dunion</b> &lt;name&gt;
<dd>Create instance of struct

<pre width=80>
        <b class="k">.union</b>          <i>;anonymous union</i>
x       <b class="d">.byte</b> <span>0</span>         <i>;labels are visible</i>
y       <b class="d">.word</b> <span>0</span>         <i>;content compiled here</i>
	<b class="k">.endu</b>

nn_u    <b class="k">.union</b>          <i>;named union</i>
x       <b class="d">.byte</b> <span>0</span>         <i>;labels are not visible</i>
y       <b class="d">.word</b> <span>0</span>         <i>;no content is compiled here</i>
        <b class="k">.endu</b>           <i>;it's just a definition</i>

nn      <b class="d">.dunion</b> <span class="l">nn_u</span>    <i>;union instance here</i>

        <b>lda</b> <span class="l">nn</span>.<span class="l">x</span>        <i>;access internal fields</i>
        <b>ldy</b> #<span class="l">nn_u</span>.<span class="l">x</span>     <i>;get offset of field</i>
</pre>

<p>The example below shown how to define structure to a binary include.</p>

<pre width=80>
        <b class="k">.union</b>
        <b class="d">.binary</b> <span class="s">"pic.drp"</span>,<span>2</span>
        <b class="k">.struct</b>
color	<b class="d">.fill</b> <span>1024</span>
screen	<b class="d">.fill</b> <span>1024</span>
bitmap	<b class="d">.fill</b> <span>8000</span>
backg	<b class="d">.byte</b> <span>?</span>
        <b class="k">.ends</b>
	<b class="k">.endu</b>
</pre>

<p>Anonymous structs and unions in combination with sections are useful for
overlapping memory assignment. The example below shares zeropage allocations
for two separate parts of a bigger program. The common subroutine variables
are assigned after in the <q>zp</q> section.</p>

<pre width=80>
        <b>*=</b> <span>$02</span>
        <b class="k">.union</b>          <i>;spare some memory</i>
        <b class="k">.struct</b>
        <b class="k">.dsection</b> <span class="l">zp1</span>   <i>;declare zp1 section</i>
        <b class="k">.send</b> <span class="l">zp1</span>
        <b class="k">.ends</b>
        <b class="k">.struct</b>
        <b class="k">.dsection</b> <span class="l">zp2</span>   <i>;declare zp2 section</i>
        <b class="k">.send</b> <span class="l">zp2</span>
        <b class="k">.ends</b>
	<b class="k">.endu</b>
        <b class="k">.dsection</b> <span class="l">zp</span>    <i>;declare zp section</i>
        <b class="k">.send</b> <span class="l">zp</span>
</pre>
</dl>

<h3>Macros</h3>
<dl class="dir">
<dt><b>.macro</b>
<dd>Each invocation is a copy of the macro's content. The code is enclosed in
it's own block so symbols inside are non-accessible.
<dt><b>.segment</b>
<dd>Only copies the code segment as it is, so symbols can be used from
outside, but this also means multiple use will result in double defines
unless anonymous labels are used.
<dt><b>.endm</b>
<dd>End of .macro or .segment definition

<pre width=80>
fill    <b class="k">.macro</b>
lp      <b>sta</b> \1,x
	<b>inx</b>
        <b>bne</b> <span class="l">lp</span>
	<b class="k">.endm</b>

name    <b class="k">.segment</b>
        <b>sta</b> <span>$d020</span>
        <b>sta</b> <span>$d021</span>
	<b class="k">.endm</b>

        <b>lda</b> #<span>1</span>
	#name           <i>;call macro</i>
        #fill <span>$400</span>
        #fill <span>$500</span>
</pre>

<dt><h4>Parameter references</h4>
<dd>Parameters can be referenced by <tt>\1</tt>...<tt>\9</tt> and <tt>\a</tt>...<tt>\z</tt>.
<tt>\@</tt> will return the entire parameter list.
<pre width=80>
name	<b class="k">.macro</b>
	<b>lda</b> #\1 	<i>;first parameter</i>
	<b class="k">.endm</b>

        #name <span>23</span>	<i>;call macro</i>
</pre>


<dt><h4>Text references</h4>
<dd>In the original turbo assembler normal references are passed by value and can
only appear in place of one. Text references on the other hand can appear every
where and will work in place of eg quoted text or opcodes and labels.
The first 9 parameters can be referenced as text by <tt>@1</tt>...<tt>@9</tt>.
<pre width=80>
name    <b class="k">.macro</b>
        <b>jsr</b> <span class="l">print</span>
        <b class="d">.null</b> <span class="s">"Hello <span>@1</span>!"</span><i>;first parameter</i>
	<b class="k">.endm</b>

	#name wth?	<i>;call macro</i>
</pre>

</dl>
<h3>Conditional assembly</h3>
<dl class="dir">
<dt><b>.if</b> &lt;expression&gt;
<dt><b>.ifne</b> &lt;expression&gt;
<dd>Conditional compile, if result is not 0
<dt><b>.ifeq</b> &lt;expression&gt;
<dd>Conditional compile, if result is 0
<dt><b>.ifpl</b> &lt;expression&gt;
<dd>Conditional compile, if result is greater or equal 0
<dt><b>.ifmi</b> &lt;expression&gt;
<dd>Conditional compile, if result is less than 0
<dt><b>.fi</b>
<dt><b>.endif</b>
<dd>End of conditional compile

<pre width=80>
        <b class="k">.if</b> <span class="l">oeu</span>=<span>1</span>
	<b>nop</b>
	<b class="k">.else</b>
        <b>lda</b> #<span>1</span>
	<b class="k">.fi</b>
</pre>

<dt><b>.else</b>
<dd>Compile, if the previous conditions were not true.

<dt><b>.elsif</b> &lt;expression&gt;
<dd>Conditional compile, if the previous conditions were not true and the result is not 0.
<pre width=80>
        <b class="k">.if</b> <span class="l">wait</span>=<span>2</span>	;2 cycles
	<b>nop</b>
        <b class="k">.elsif</b> <span class="l">wait</span>=<span>3</span>	;3 cycles
        <b>bit</b> <span>$ea</span>
        <b class="k">.elsif</b> <span class="l">wait</span>=<span>4</span>	;4 cycles
        <b>bit</b> <span>$eaea</span>
	<b class="k">.else</b>		;else 5 cycles
        <b>inc</b> <span>$2</span>
	<b class="k">.fi</b>
</pre>

<dt><b>.for</b> &lt;variable&gt;=&lt;expression&gt;,&lt;expression&gt;,&lt;variable&gt;=&lt;expression&gt;
<dt><b>.next</b>
<dd>Compile loop, only anonymous references are allowed as labels inside
<pre width=80>
        <b class="k">.for</b> <span class="l">ue</span>=<span>0</span>,<span class="l">ue</span>&lt;<span>10</span>,<span class="l">ue</span>=<span class="l">ue</span>+<span>1</span>
        <b class="d">.byte</b> <span class="l">ue</span>
	<b class="k">.next</b>
</pre>

<dt><b>.rept</b> &lt;expression&gt;
<dt><b>.next</b>
<dd>Repeated compile, only anonymous references are allowed as labels inside
<pre width=80>
        <b class="k">.rept</b> <span>100</span>
	<b>nop</b>
	<b class="k">.next</b>
</pre>

<dt><b>.lbl</b>
<dd>Creates a special jump label that can be referenced by <code>.goto</code>
<dt><b>.goto</b> &lt;labelname&gt;
<dd>Causes assembler to continue assembling from the jump label. No
forward references of course, handle with care. Typically used in
classic TASM sources for creating loops.

<pre width=80>
i	<b class="k">.var</b> <span>100</span>
loop	<b class="k">.lbl</b>
        <b>nop</b>
i       <b class="k">.var</b> <span class="l">i</span> - <span>1</span>
        <b class="k">.ifne</b> <span class="l">i</span>
        <b class="k">.goto</b> <span class="l">loop</span>       <i>;generates 100 nops</i>
        <b class="k">.fi</b>
</pre>

</dl>
<h3>Including files</h3>
<dl class="dir">
<dt><b>.include</b> "&lt;filename&gt;"
<dd>Include source file here, path is relative to the location of current
source file. The filename can be a string expression but it must be defined in
advance.
<pre width=80>
	<b class="k">.include</b> <span class="s">"macros.asm"</span>
</pre>

<dt><b>.binary</b> "&lt;filename&gt;"[, &lt;offset&gt;[, &lt;length&gt;]]
<dd>Include binary data, path is relative to the location of current
source file. Please note that <q>loading address</q> is ignored, and if
not skipped then it's also loaded as data. By using offset and length
it's possible to break out chunks of data from a file separately, like
bitmap and colors for example. The filename can be a string expression.
<pre width=80>
        <b class="d">.binary</b> <span class="s">"stuffz.bin"</span>        <i>;simple include, all bytes</i>
        <b class="d">.binary</b> <span class="s">"stuffz.bin"</span>,<span>2</span>      <i>;skip start address</i>
        <b class="d">.binary</b> <span class="s">"stuffz.bin"</span>,<span>2</span>,<span>1000</span> <i>;skip start address, 1000 bytes max</i>

        <b>*=</b> <span>$1000</span>	            <i>;load music to $1000 and</i>
        <b class="d">.binary</b> <span class="s">"music.dmc"</span>,<span>2</span>       <i>;strip load address</i>
</pre>

</dl>
<h3>Blocks</h3>
<dl class="dir">
<dt><b>.proc</b>
<dd>Procedure start
<dt><b>.pend</b>
<dd>End of procedure
<pre width=80>
ize     <b class="k">.proc</b>
	<b>nop</b>
cucc    <b>nop</b>
	<b class="k">.pend</b>

        <b>jsr</b> <span class="l">ize</span>
        <b>jmp</b> <span class="l">ize</span>.<span class="l">cucc</span>
</pre>
If <q>ize</q> is not referenced then the code won't be compiled at all!
All labels inside are local.

<dt><b>.block</b>
<dd>Block start
<dt><b>.bend</b>
<dd>End of Block
<pre width=80>
	<b class="k">.block</b>
        <b>inc</b> <span class="l">count</span> + <span>1</span>
count	<b>ldx</b> #<span>0</span>
	<b class="k">.bend</b>
</pre>
    All labels inside a block are local.


<dt><b>.comment</b>
<dd>Comment block start
<dt><b>.endc</b>
<dd>End of comment block
<pre width=80>
	<b class="k">.comment</b><i>
	lda #1          ;this won't be compiled
	sta $d020
	</i><b class="k">.endc</b>
</pre>
</dl>

<h3>Sections</h3>
<dl class="dir">
<dt><b>.dsection</b> &lt;name&gt;
<dd>Declares a named section and starts it.
<dt><b>.section</b> &lt;name&gt;
<dd>Section start
<dt><b>.send</b> [&lt;name&gt;]
<dd>End of section. Section name is optional, if present it must match.
<p>Sections are useful for linking sources, or to organize memory layout. With
them it's easily possible to allocate addresses for variables at the place of
actual use enclosed by the current scope. It can also be used to collect data
or code to specific memory areas, or to ease the generation of code and data to
multiple locations simultaniously in a single loop or macro.</p>
<p>All <code>.section</code>-s scattered around in the sources are compiled
from the <code>.dsection</code> declaration. Compilation happens as the code
appears, this directive only assigns enough space to hold all the stuff in the
sections. Where the <code>.dsection</code> appears the section's private
address and logical address are initialized to the current values.</p>
<p>The space allocated is calculated by the difference of the initial private
address and the private address after the last section was compiled. It is
possible to adjust the address in sections in a non incremental way, but it
must be done carefully otherwise the space allocation will be not right, in
that case you must manually adjust the address and logical address after the
section declaration.</p>
<p>Sections and section declarations can be nested, therefore it's possible to
have the same names as long as it's inside a differently named section. Parent
section names are visible for children, siblings can be reached through
parents.</p>
<pre width=80>
        <b>*=</b> <span>$02</span>
        <b class="k">.dsection</b> <span class="l">zp</span>   <i>;declare zeropage section</i>
        <b class="k">.send</b> <span class="l">zp</span>
        <b class="k">.cerror</b> *&gt;<span>$30</span>,<span class="s">"Too many zeropage variables"</span>

        <b>*=</b> <span>$334</span>
        <b class="k">.dsection</b> <span class="l">bss</span>   <i>;declare uninitialized variable section</i>
        <b class="k">.send</b> <span class="l">bss</span>
        <b class="k">.cerror</b> *&gt;<span>$400</span>,<span class="s">"Too many variables"</span>

        <b>*=</b> <span>$0801</span>
        <b class="k">.dsection</b> <span class="l">code</span>   <i>;declare code section</i>
        <b class="d">.word</b> <span class="l">ss</span>, <span>2005</span>
        <b class="d">.null</b> <span>$9e</span>, ^<span class="l">start</span>
ss	<b class="d">.word</b> <span>0</span>
        <b class="k">.send</b> <span class="l">code</span>
        <b class="k">.cerror</b> *&gt;<span>$1000</span>,<span class="s">"Program too long!"</span>

        <b>*=</b> <span>$1000</span>
        <b class="k">.dsection</b> <span class="l">data</span>   <i>;declare data section</i>
        <b class="k">.send</b> <span class="l">data</span>
        <b class="k">.cerror</b> *&gt;<span>$2000</span>,<span class="s">"Data too long!"</span>
<i>;--------------------</i>
        <b class="k">.section</b> <span class="l">code</span>
start   <b>sei</b>
        <b class="k">.section</b> <span class="l">zp</span>     <i>;declare some new zeropage variables</i>
p2	<b class="d">.word</b> <span>?</span>         <i>;a pointer</i>
        <b class="k">.send</b> <span class="l">zp</span>
        <b class="k">.section</b> <span class="l">bss</span>    <i>;new variables</i>
buffer	<b class="d">.fill</b> <span>10</span>        <i>;temporary area</i>
        <b class="k">.send</b> <span class="l">bss</span>

        <b>lda</b> (<span class="l">p2</span>),y
        <b>lda</b> #&lt;<span class="l">label</span>
        <b>ldy</b> #&gt;<span class="l">label</span>
        <b>jsr</b> <span class="l">print</span>

        <b class="k">.section</b> <span class="l">data</span>   <i>;some data</i>
label   <b class="d">.null</b> <span class="s">"message"</span>
        <b class="k">.send</b> <span class="l">data</span>

        <b>jmp</b> <span class="l">error</span>
        <b class="k">.section</b> <span class="l">zp</span>     <i>;declare some more zeropage variables</i>
p3	<b class="d">.word</b> <span>?</span>         <i>;a pointer</i>
        <b class="k">.send</b> <span class="l">zp</span>
        <b class="k">.send</b> <span class="l">code</span>
</pre>
<p>The compiled code will look like:</p>
</dl>
<pre width=80>
&gt;0801	 0b 08 d5 07			        .word ss, 2005   
&gt;0805	 9e 32 30 36 31 00		        .null $9e, ^start
&gt;080b	 00 00				ss      .word 0          

					        *= $1000

.080d	 78				start   sei

&gt;0002					p2      .word ?         ;a pointer
.0334					buffer  .fill 10        ;temporary area

.080e	 b1 02				        lda (p2),y
.0810	 a9 00				        lda #&lt;label
.0812	 a0 10				        ldy #&gt;label
.0814	 20 1e ab			        jsr print

&gt;1000	 6d 65 73 73 61 67 65 00	label   .null "message"

.0817	 4c e2 fc			        jmp error

&gt;0004					p2      .word ?         ;a pointer
</pre>

<h3>65816 related</h3>
<dl class="dir">
<dt><b>.as</b>
<dd>Select 8 bit accu (65816)

<dt><b>.al</b>
<dd>Select 16 bit accu (65816). Immediate constants of a register using opcodes will use 16 bits.
<pre width=80>
	<b class="k">.al</b>
        <b>lda</b> #<span>$4322</span>
</pre>

<dt><b>.xs</b>
<dd>Select 8 bit index (65816)

<dt><b>.xl</b>
<dd>Select 16 bit index (65816). Immediate constants of x and y register using opcodes will use 16 bits.
<pre width=80>
	<b class="k">.xl</b>
        <b>ldx</b> #<span>$1000</span>
</pre>

<dt><b>.databank</b> &lt;expression&gt;
<dd>Set databank (65816). Absolute addressing is used only for symbols in this
bank, anything else (except direct page) is using long addressing.
<pre width=80>
        <b class="k">.databank</b> <span>$10</span>   ;$10xxxx
</pre>

<dt><b>.dpage</b> &lt;expression&gt;
<dd>Set directpage (65816/C128/DTV) (forced to page boundary for DTV). Direct
page addressing is only used for addresses in the following 256 byte range, anything
else is using absolute or long addressing.
<pre width=80>
        <b class="k">.dpage</b> <span>$400</span>
</pre>

</dl>
<h3>Controlling errors</h3>
<dl class="dir">

<dt><b>.page</b>
<dd>Gives an error on page boundary crossing, eg. for timing sensitive code.
<dt><b>.endp</b>
<dd>End of page cross checking

<pre width=80>
	<b class="k">.page</b>
table   <b class="d">.byte</b> <span>0</span>,<span>1</span>,<span>2</span>,<span>3</span>,<span>4</span>,<span>5</span>,<span>6</span>,<span>7</span>
	<b class="k">.endp</b>
</pre>

<dt><b>.option</b> allow_branch_across_page
<dd>Switches error generation on page boundary crossing during relative branch.
Such a condition on 6502 adds 1 extra cycle to the execution time, which
can ruin the timing of a carefuly cycle counted code.
<pre width=80>
        <b class="k">.option</b> allow_branch_across_page = <span>0</span>
        <b>ldx</b> #<span>3</span>          <i>;now this will execute in</i>
-       <b>dex</b>             <i>;16 cycles for sure</i>
	<b>bne</b> -
        <b class="k">.option</b> allow_branch_across_page = <span>1</span>
</pre>

<dt><b>.error</b> &lt;message&gt; [, &lt;message&gt;, ...]
<dd>Exit with error
<dt><b>.cerror</b> &lt;expression&gt;, &lt;message&gt; [, &lt;message&gt;, ...]
<dd>Conditional exit with error
<pre width=80>
        <b class="k">.error</b> <span class="s">"Unfinished here..."</span>
        <b class="k">.cerror</b> *&gt;<span>$1200</span>, <span class="s">"Program too long by "</span>, *-<span>$1200</span>, <span class="s">" bytes"</span>
</pre>

<dt><b>.warn</b> &lt;message&gt; [, &lt;message&gt;, ...]
<dd>Warning
<dt><b>.cwarn</b> &lt;expression&gt;, &lt;message&gt; [, &lt;message&gt;, ...]
<dd>Conditional warning
<pre width=80>
        <b class="k">.warn</b> <span class="s">"FIXME: handle negative values too!"</span>
        <b class="k">.cwarn</b> *&gt;<span>$1200</span>, <span class="s">"This may not work!"</span>
</pre>

</dl>
<h3>Target</h3>
<dl class="dir">

<dt><b>.cpu</b> &lt;cpuname&gt;
<dd>Selects cpu
<pre width=80>
	<b class="k">.cpu</b> 6502	<i>;standard 65xx</i>
	<b class="k">.cpu</b> 65c02	<i>;CMOS 65C02</i>
	<b class="k">.cpu</b> 65ce02	<i>;CSG 65CE02</i>
	<b class="k">.cpu</b> 6502i	<i>;NMOS 65xx</i>
	<b class="k">.cpu</b> 65816	<i>;W65C816</i>
	<b class="k">.cpu</b> 65dtv02	<i>;65dtv02</i>
	<b class="k">.cpu</b> 65el02	<i>;65el02</i>
	<b class="k">.cpu</b> r65c02	<i>;R65C02</i>
	<b class="k">.cpu</b> w65c02	<i>;W65C02</i>
	<b class="k">.cpu</b> default	<i>;cpu set on commandline</i>
</pre>

</dl>
<h3>Misc</h3>
<dl class="dir">

<dt><b>.end</b>
<dd>Terminate assembly. Any content after this directive is ignored.

<dt><b>.eor</b> &lt;expression&gt;
<dd>Eor output with some 8 bit value. Useful for reverse screencode text for example,
or for silly <q>encryption</q>.

<dt><b>.var</b> &lt;expression&gt;
<dd>Defines a variable identified by the label preceeding, which
is set to the value of expression.

<dt><b>.assert</b>
<dt><b>.check</b>
<dd>Do not use these, the syntax will change in next version!

</dl>
<h3>Printer control</h3>
<dl class="dir">

<dt><b>.pron</b>
<dt><b>.proff</b>
<dd>Turn on or off source listing on part of the file.

<dt><b>.hidemac</b>
<dt><b>.showmac</b>
<dd>Ignored for compatibility
</dl>

<hr>
<h2>How to convert source code written for the original turbo assembler for use
with 64tass</h2>

Currently there are two options, either use <q>TMPview</q> by Style to convert the
sourcefile directly, or do the following:
<ul>
<li>load turbo assembler, start (by sys9*4096 or sys8*4096 depending on version)
<li><- (arrow left) then l to load a sourcefile
<li><- (arrow left) then w to write a sourcefile in petscii format
<li>convert the result to ascii using petcat (from the vice package)
</ul>
the resulting file should then (with the restrictions below) assemble using the
following commandline:<br>
<p>
<tt>64tass -C -T -a -W -i source.s -o outfile.prg</tt>
</p>
<hr>
<h2>Differences to the original turbo ass macro on the C64</h2>
<p>
64tass is nearly 100% compatible with the original <q>Turbo Assembler</q>, and supports
most of the features of the original <q>Turbo Assembler Macro</q>.
The remaining notable differences are listed here:
</p>
<h3>Labels</h3>
<p>
The original turbo assembler uses case sensitive labels, use the <tt>-C, --case-sensitive</tt>
option to enable this behaviour.
</p>
<p>
Another thing worth noting is that the original turbo assembler lets you create
an interesting ambiguous construct using a label called <q>a</q>.
</p>
<pre width=80>
	<b>lsr a</b>    ; uses accu ! (or does it really?)
a
        <b>jmp</b> <span class="l">a</span>    ; uses the label address
        <b class="d">.word</b> <span class="l">a</span>  ; uses the label address
</pre>
<p>
If you get a warning like <q><tt>warning: Possibly incorrectly used A "lsr a"</tt></q>, then there
is such an ambiguous situation in your code and you should fix it (by renaming the label).
</p>

<h3>Expression evaluation</h3>

<p>There are a few differences which can be worked around by the <tt>-T, --tasm-compatible</tt> option.
These are:</p>

<p>The original expression parser has no operator precedence, but 64tass has. That
means that you will have to fix expressions using braces accordingly, for example
<code>1+2*3</code> becomes <code>(1+2)*3</code>.</p>

<p>The following operators used by the original Turbo Assembler are different:</p>
<ul>
<li><tt>.</tt> for bitwise or, now <tt>|</tt>
<li><tt>:</tt> for bitwise eor, now <tt>^</tt>
<li><tt>!</tt> to force 16&nbsp;bit address, now <tt>@w</tt>
</ul>

<p>The default expression evaluation is not limited to 16 bit unsigned numbers anymore.</p>

<h3>Macros</h3>
<ul>
<li>Macro parameters are referenced by <tt>\1</tt>...<tt>\9</tt> instead of using the pound sign
<li>Parameters are always copied as text into the macro and not passed by value as the
original turbo assembler does, which sometimes may lead to unexpected behaviour. You may
need to make use of braces around arguments and/or references to fix this.
</ul>

<h3>Bugs</h3>
Some versions of the original turbo assembler had bugs that are not reproduced
by 64tass, you will have to fix the code instead.
<ul>
<li>In some versions labels used in the first .block are globally available. If
you get a related error move the respective label out of the .block
</ul>

<hr>
<h2>Messages</h2>

<h3>Warnings</h3>
<dl>
<dt>Top of memory excedeed
<dd>compile continues at the bottom ($0000)
<dt>Possibly incorrectly used A
<dd>do not use <q>a</q> as label
<dt>Memory bank excedeed
<dd>compile continues in the next 64&nbsp;KiB bank, however execution may not
<dt>Possible jmp ($xxff) bug
<dd>yet another 65xx feature...
<dt>Long branch used
<dd>Branch too long, so long branch was used (bxx *+5 jmp)
<dt>Directive ignored
<dd>An assembler directive was ignored for compatibility reasons.
</dl>

<h3>Errors</h3>
<dl>
<dt>Double defined
<dd>double use of label/macro
<dt>Not defined
<dd>not defined label
<dt>Extra characters on line
<dd>there's some garbage on the end of line
<dt>Constant too large
<dd>the number was too big
<dt>General syntax
<dd>can't do anything with this
<dt>X expected
<dd>X may be missing
<dt>Expression syntax
<dd>syntax error
<dt>Branch too far
<dd>can't relative branch that far
<dt>Missing argument
<dd>no argument given
<dt>Illegal operand
<dd>can't be used here
<dt>Requirements not met:
<dd>Not all features are provided, at least one is missing
<dt>Conflict:
<dd>at least one feature is provided, which shouldn't be there
<dt>Division by zero
<dd>Cannot calculate value
</dl>

<h3>Fatal errors</h3>
<dl>
<dt>Can't locate file
<dd>cannot open file
<dt>Out of memory
<dd>won't happen ;)
<dt>Can't write object file:
<dd>cannot write the result
<dt>Line too long
<dd>input line was too long
<dt>Can't write listing file:
<dd>cannot write the list file
<dt>Can't write label file:
<dd>cannot write the label file
<dt>File recursion
<dd>wrong use of .include
<dt>Macro recursion too deep
<dd>wrong use of nested macros
<dt>Unknown CPU
<dd>CPU type not known
<dt>Ooops! Too many passes...
<dd>With a carefuly crafted source file it's possible to create unresolvable situations. Fix your code.
</dl>

<hr>
<h2>Standard 6502 opcodes</h2>
<p>The standard 6502 opcodes:</p>
<pre>
ADC $61, $65, $69, $6D, $71, $75, $79, $7D
AND $21, $25, $29, $2D, $31, $35, $39, $3D
ASL $06, $0A, $0E, $16, $1E
BCC $90
BCS $B0
BEQ $F0
BIT $24, $2C
BMI $30
BNE $D0
BPL $10
BRK $00
BVC $50
BVS $70
CLC $18
CLD $D8
CLI $58
CLV $B8
CMP $C1, $C5, $C9, $CD, $D1, $D5, $D9, $DD
CPX $E0, $E4, $EC
CPY $C0, $C4, $CC
DEC $C6, $CE, $D6, $DE
DEX $CA
DEY $88
EOR $41, $45, $49, $4D, $51, $55, $59, $5D
INC $E6, $EE, $F6, $FE
INX $E8
INY $C8
JMP $4C, $6C
JSR $20
LDA $A1, $A5, $A9, $AD, $B1, $B5, $B9, $BD
LDX $A2, $A6, $AE, $B6, $BE
LDY $A0, $A4, $AC, $B4, $BC
LSR $46, $4A, $4E, $56, $5E
NOP $EA
ORA $01, $05, $09, $0D, $11, $15, $19, $1D
PHA $48
PHP $08
PLA $68
PLP $28
ROL $26, $2A, $2E, $36, $3E
ROR $66, $6A, $6E, $76, $7E
RTI $40
RTS $60
SBC $E1, $E5, $E9, $ED, $F1, $F5, $F9, $FD
SEC $38
SED $F8
SEI $78
STA $81, $85, $8D, $91, $95, $99, $9D
STX $86, $8E, $96
STY $84, $8C, $94
TAX $AA
TAY $A8
TSX $BA
TXA $8A
TXS $9A
TYA $98
</pre>
<p>Aliases, pseudo instructions:</p>
<pre>
ASL $0A
BGE $B0
BLT $90
GCC $4C, $90
GCS $4C, $B0
GEQ $4C, $F0
GGE $4C, $B0
GLT $4C, $90
GMI $30, $4C
GNE $4C, $D0
GPL $10, $4C
GVC $4C, $50
GVS $4C, $70
LSR $4A
ROL $2A
ROR $6A
</pre>

<hr>
<h2>6502 illegal opcodes</h2>
<p>The standard 6502 opcodes, plus additionally:</p>
<pre>
ANC $0B
ANE $8B
ARR $6B
ASR $4B
DCP $C3, $C7, $CF, $D3, $D7, $DB, $DF
ISB $E3, $E7, $EF, $F3, $F7, $FB, $FF
JAM $02
LAX $A3, $A7, $AB, $AF, $B3, $B7, $BF
LDS $BB
NOP $04, $0C, $14, $1C, $80
RLA $23, $27, $2F, $33, $37, $3B, $3F
RRA $63, $67, $6F, $73, $77, $7B, $7F
SAX $83, $87, $8F, $97
SBX $CB
SHA $93, $9F
SHS $9B
SHX $9E
SHY $9C
SLO $03, $07, $0F, $13, $17, $1B, $1F
SRE $43, $47, $4F, $53, $57, $5B, $5F
</pre>
<p>Additional aliases:</p>
<pre>
AHX $93, $9F
ALR $4B
AXS $CB
DCM $C3, $C7, $CF, $D3, $D7, $DB, $DF
INS $E3, $E7, $EF, $F3, $F7, $FB, $FF
ISC $E3, $E7, $EF, $F3, $F7, $FB, $FF
LAE $BB
LAS $BB
LXA $AB
TAS $9B
XAA $8B
</pre>

<hr>
<h2>65DTV02 opcodes</h2>
<p>Additionally to 6502 illegal opcodes:</p>
<pre>
BRA $12
SAC $32
SIR $42
</pre>
<p>Additional pseudo instruction:</p>
<pre>
GRA $12, $4C
</pre>
<p>These illegal opcodes are not valid:</p>
<pre>
ANC $0B
JAM $02
LDS $BB
NOP $04, $0C, $14, $1C, $80
SBX $CB
SHA $93, $9F
SHS $9B
SHX $9E
SHY $9C
</pre>
<p>These illegal aliases are not valid:</p>
<pre>
AHX $93, $9F
AXS $CB
LAE $BB
LAS $BB
TAS $9B
</pre>
</table>

<hr>
<h2>Standard 65C02 opcodes</h2>
<p>Additional opcodes to standard 6502:</p>
<pre>
ADC $72
AND $32
BIT $34, $3C, $89
BRA $80
CMP $D2
DEC $3A
EOR $52
INC $1A
JMP $7C
LDA $B2
ORA $12
PHX $DA
PHY $5A
PLX $FA
PLY $7A
SBC $F2
STA $92
STZ $64, $74, $9C, $9E
TRB $14, $1C
TSB $04, $0C
</pre>
<p>Additional aliases and pseudo instructions:</p>
<pre>
DEA $3A
GRA $4C, $80
INA $1A
</pre>

<hr>
<h2>R65C02 opcodes</h2>
<p>Additional opcodes to standard 65C02:</p>
<pre>
BBR $0F, $1F, $2F, $3F, $4F, $5F, $6F, $7F
BBS $8F, $9F, $AF, $BF, $CF, $DF, $EF, $FF
RMB $07, $17, $27, $37, $47, $57, $67, $77
SMB $87, $97, $A7, $B7, $C7, $D7, $E7, $F7
</pre>

<hr>
<h2>W65C02 opcodes</h2>
<p>Additional opcodes to R65C02:</p>
<pre>
STP $DB
WAI $CB
</pre>

<hr>
<h2>W65816 opcodes</h2>
<p>Additional opcodes to standard 65C02:</p>
<pre>
ADC $63, $67, $6F, $73, $77, $7F
AND $23, $27, $2F, $33, $37, $3F
BRL $82
CMP $C3, $C7, $CF, $D3, $D7, $DF
COP $02
EOR $43, $47, $4F, $53, $57, $5F
JMP $5C, $DC
JSL $22
JSR $FC
LDA $A3, $A7, $AF, $B3, $B7, $BF
MVN $54
MVP $44
ORA $03, $07, $0F, $13, $17, $1F
PEA $F4
PEI $D4
PER $62
PHB $8B
PHD $0B
PHK $4B
PLB $AB
PLD $2B
REP $C2
RTL $6B
SBC $E3, $E7, $EF, $F3, $F7, $FF
SEP $E2
STA $83, $87, $8F, $93, $97, $9F
STP $DB
SWA $EB
TAD $5B
TAS $1B
TCD $5B
TCS $1B
TDA $7B
TDC $7B
TSA $3B
TSC $3B
TXY $9B
TYX $BB
XBA $EB
XCE $FB
WAI $CB
</pre>

<p>Additional aliases:</p>
<pre>
JML $5C, $DC
</pre>

<hr>
<h2>65EL02 opcodes</h2>
<p>Additional opcodes to standard 65C02:</p>
<pre>
ADC $63, $67, $73, $77
AND $23, $27, $33, $37
CMP $C3, $C7, $D3, $D7
DIV $4F, $5F, $6F, $7F
ENT $22
EOR $43, $47, $53, $57
JSR $FC
LDA $A3, $A7, $B3, $B7
MMU $EF
MUL $0F, $1F, $2F, $3F
NXA $42
NXT $02
ORA $03, $07, $13, $17
PEA $F4
PEI $D4
PER $62
PHD $DF
PLD $CF
REA $44
REI $54
REP $C2
RER $82
RHA $4B
RHI $0B
RHX $1B
RHY $5B
RLA $6B
RLI $2B
RLX $3B
RLY $7B
SBC $E3, $E7, $F3, $F7
SEA $9F
SEP $E2
STA $83, $87, $93, $97
STP $DB
SWA $EB
TAD $BF
TDA $AF
TIX $DC
TRX $AB
TXI $5C
TXR $8B
TXY $9B
TYX $BB
WAI $CB
XBA $EB
XCE $FB
ZEA $8F
</pre>

<hr>
<h2>65CE02 opcodes</h2>
<p>Additional opcodes to R65C02:</p>
<pre>
ASR $43, $44, $54
ASW $CB
BCC $93
BCS $B3
BEQ $F3
BMI $33
BNE $D3
BPL $13
BRA $83
BSR $63
BVC $53
BVS $73
CLE $02
CPZ $C2, $D4, $DC
DEW $C3
DEZ $3B
INW $E3
INZ $1B
JSR $22, $23
LDA $E2
LDZ $A3, $AB, $BB
NEG $42
PHW $F4, $FC
PHZ $DB
PLZ $FB
ROW $EB
RTS $62
SEE $03
STA $82
STX $9B
STY $8B
TAB $5B
TAZ $4B
TSY $0B
TYS $2B
TZA $6B
</pre>

<p>Additional aliases to R65C02:</p>
<pre>
ASR $43
BGE $B3
BLT $93
NEG $42
RTN $62
</pre>
</body></html>
